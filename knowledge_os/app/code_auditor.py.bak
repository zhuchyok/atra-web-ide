import asyncio
import os
import json
import asyncpg
import subprocess
from datetime import datetime, timezone
from resource_manager import acquire_resource_lock

DB_URL = os.getenv('DATABASE_URL', 'postgresql://zhuchyok@localhost:5432/knowledge_os')

PROJECT_ROOT = "/root/knowledge_os"

def run_cursor_agent(prompt: str):
    """Run cursor-agent CLI to process a prompt and return output."""
    try:
        env = os.environ.copy()
        result = subprocess.run(
            ["/root/.local/bin/cursor-agent", "--print", prompt],
            capture_output=True,
            text=True,
            check=True,
            timeout=600,
            env=env
        )
        return result.stdout
    except Exception as e:
        print(f"Error running cursor-agent for audit: {e}")
        return None

async def run_code_audit():
    async with acquire_resource_lock("code_auditor"):
        print("üé≠ Starting Cognitive Mirror (Code Auditor)...")
        conn = await asyncpg.connect(DB_URL)
        
        # 1. –°–æ–±–∏—Ä–∞–µ–º —Å–ø–∏—Å–æ–∫ —Ñ–∞–π–ª–æ–≤ –∏ –ª–æ–≥–∏ –ø–æ—Å–ª–µ–¥–Ω–∏—Ö –æ—à–∏–±–æ–∫
        files = []
        for root, dirs, filenames in os.walk(os.path.join(PROJECT_ROOT, "app")):
            for f in filenames:
                if f.endswith(".py"):
                    files.append(f) # –¢–æ–ª—å–∫–æ –∏–º–µ–Ω–∞ —Ñ–∞–π–ª–æ–≤ –¥–ª—è —ç–∫–æ–Ω–æ–º–∏–∏ –º–µ—Å—Ç–∞
        
        log_dir = os.path.join(PROJECT_ROOT, "logs")
        logs_content = ""
        if os.path.exists(log_dir):
            for f in os.listdir(log_dir):
                if f.endswith(".log"):
                    try:
                        with open(os.path.join(log_dir, f), 'r') as log_file:
                            content = log_file.read()
                            logs_content += f"\n--- {f} ---\n" + content[-1000:] # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 1–ö–ë –ª–æ–≥–æ–≤ –Ω–∞ —Ñ–∞–π–ª
                    except: pass
        
        # –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –æ–±—â–∏–π —Ä–∞–∑–º–µ—Ä –ø—Ä–æ–º–ø—Ç–∞
        if len(logs_content) > 3000:
            logs_content = logs_content[-3000:]

        # 2. –ü—Ä–æ–º–ø—Ç –¥–ª—è –∞—É–¥–∏—Ç–∞ –∫–æ–¥–∞
        audit_prompt = f"""
        –¢–´ - –ì–õ–ê–í–ù–´–ô –ê–†–•–ò–¢–ï–ö–¢–û–† –ò SRE –ö–û–†–ü–û–†–ê–¶–ò–ò.
        –¢–í–û–Ø –ó–ê–î–ê–ß–ê: –ü—Ä–æ–≤–µ–¥–∏ –∞—É–¥–∏—Ç —Å–æ–±—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ –∫–æ–¥–∞ –∏ –ª–æ–≥–æ–≤ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç –æ—à–∏–±–æ–∫, —É—è–∑–≤–∏–º–æ—Å—Ç–µ–π –∏ –Ω–µ—ç—Ñ—Ñ–µ–∫—Ç–∏–≤–Ω–æ—Å—Ç–∏.
        
        –°–ü–ò–°–û–ö –§–ê–ô–õ–û–í: {files}
        –ü–û–°–õ–ï–î–ù–ò–ï –õ–û–ì–ò:
        {logs_content}
        
        –ó–ê–î–ê–ß–ê:
        1. –ü—Ä–æ–∞–Ω–∞–ª–∏–∑–∏—Ä—É–π –ª–æ–≥–∏ –Ω–∞ –ø—Ä–µ–¥–º–µ—Ç –ø–æ–≤—Ç–æ—Ä—è—é—â–∏—Ö—Å—è –æ—à–∏–±–æ–∫.
        2. –ù–∞–π–¥–∏ –ø–æ—Ç–µ–Ω—Ü–∏–∞–ª—å–Ω—ã–µ "–±—É—Ç—ã–ª–æ—á–Ω—ã–µ –≥–æ—Ä–ª—ã—à–∫–∏" –≤ –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–µ.
        3. –°–≥–µ–Ω–µ—Ä–∏—Ä—É–π —Å–ø–∏—Å–æ–∫ –∫–æ–Ω–∫—Ä–µ—Ç–Ω—ã—Ö –∑–∞–¥–∞—á –ø–æ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—é.
        
        –í–ï–†–ù–ò JSON –°–ü–ò–°–û–ö –ó–ê–î–ê–ß:
        [
            {{
                "title": "–ó–∞–≥–æ–ª–æ–≤–æ–∫ –∑–∞–¥–∞—á–∏",
                "description": "–ü–æ–¥—Ä–æ–±–Ω–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∏ —á—Ç–æ –∏—Å–ø—Ä–∞–≤–∏—Ç—å",
                "department": "Backend/DevOps/ML",
                "severity": "high/medium/low"
            }}
        ]
        –í–ï–†–ù–ò –¢–û–õ–¨–ö–û JSON.
        """
        
        output = run_cursor_agent(audit_prompt)
        
        if output:
            try:
                clean_json = output.strip()
                if "```json" in clean_json:
                    clean_json = clean_json.split("```json")[1].split("```")[0]
                elif "```" in clean_json:
                    clean_json = clean_json.split("```")[1].split("```")[0]
                
                tasks = json.loads(clean_json)
                
                victoria_id = await conn.fetchval("SELECT id FROM experts WHERE name = '–í–∏–∫—Ç–æ—Ä–∏—è'")
                
                for t in tasks:
                    # –ù–∞—Ö–æ–¥–∏–º –ø–æ–¥—Ö–æ–¥—è—â–µ–≥–æ —ç–∫—Å–ø–µ—Ä—Ç–∞
                    assignee = await conn.fetchrow("""
                        SELECT id FROM experts 
                        WHERE department = $1 OR role ILIKE $2 
                        ORDER BY RANDOM() LIMIT 1
                    """, t['department'], f"%{t['department']}%")
                    
                    assignee_id = assignee['id'] if assignee else victoria_id
                    
                    await conn.execute("""
                        INSERT INTO tasks (title, description, status, assignee_expert_id, creator_expert_id, metadata)
                        VALUES ($1, $2, 'pending', $3, $4, $5)
                    """, f"ü§ñ AUTO-AUDIT: {t['title']}", t['description'], assignee_id, victoria_id, 
                    json.dumps({"source": "code_auditor", "severity": t['severity']}))
                    
                    print(f"üìå Created auto-audit task: {t['title']} ({t['severity']})")

                    # –ï—Å–ª–∏ –∫—Ä–∏—Ç–∏—á–Ω–æ - –ø–∏—à–µ–º –≤ –Ω–æ—Ç–∏—Ñ–∏–∫–∞—Ü–∏–∏
                    if t['severity'] == 'high':
                        await conn.execute("""
                            INSERT INTO notifications (message, type)
                            VALUES ($1, 'system_alert')
                        """, f"üß® CRITICAL AUDIT: {t['title']}")

            except Exception as e:
                print(f"‚ùå Error parsing audit output: {e}")

        await conn.close()


if __name__ == "__main__":
    asyncio.run(run_code_audit())

