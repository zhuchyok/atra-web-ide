# Отчет об исправлении частоты DCA сигналов

**Дата исправления:** 10 августа 2025
**Статус:** ✅ Завершено

## Проблема
Пользователь сообщил, что DCA сигналы "сыпятся постоянно" и слишком частые. Проблема заключалась в том, что DCA сигналы использовали ту же логику `should_send_signal`, что и новые торговые сигналы, но для DCA нужны более строгие условия.

## Диагностика
1. **DCA сигналы использовали стандартную логику**: `should_send_signal(df, current_index, "long", last['close'], user_id, symbol)`
2. **Недостаточно строгие условия**: DCA сигналы срабатывали слишком часто
3. **Отсутствие специальных проверок**: Нет проверок волатильности, EMA и других условий для DCA

## Исправления

### 1. Создание специальной функции `should_send_dca_signal`
**Решение**: Создана отдельная функция с более строгими условиями для DCA сигналов

```python
def should_send_dca_signal(df, i, side, price, user_id, symbol):
    """
    Специальная проверка для DCA сигналов с более строгими условиями
    DCA сигналы должны быть более редкими и точными
    """
    # Очень строгий таймаут для DCA - 30 минут
    dca_timeout = 1800  # 30 минут
    dca_tolerance = 0.005  # 0.5% - очень строгая точность

    # Дополнительные строгие проверки для DCA
    if df is not None and i is not None:
        last = df.iloc[i]

        # Для LONG DCA: цена должна быть ниже EMA20
        if side == "long":
            if 'ema20' in df.columns and last['ema20'] is not None:
                if price > last['ema20']:
                    return False, "Цена выше EMA20 для LONG DCA"

        # Для SHORT DCA: цена должна быть выше EMA20
        elif side == "short":
            if 'ema20' in df.columns and last['ema20'] is not None:
                if price < last['ema20']:
                    return False, "Цена ниже EMA20 для SHORT DCA"

        # Проверяем волатильность - DCA не должен срабатывать при слишком высокой волатильности
        if 'atr' in df.columns and last['atr'] is not None:
            avg_price = df['close'].rolling(20).mean().iloc[i]
            if avg_price > 0:
                volatility_pct = (last['atr'] / avg_price) * 100
                if volatility_pct > 5:  # Если волатильность больше 5%
                    return False, f"Слишком высокая волатильность для DCA: {volatility_pct:.1f}%"

        # Дополнительная проверка: минимальное изменение цены для DCA
        if 'close' in df.columns and len(df) > 1:
            prev_close = df['close'].iloc[i-1] if i > 0 else last['close']
            price_change_pct = abs((price - prev_close) / prev_close) * 100

            # DCA должен срабатывать только при значительном изменении цены (минимум 1%)
            if price_change_pct < 1.0:
                return False, f"Изменение цены слишком мало для DCA: {price_change_pct:.2f}%"

    return True, "DCA сигнал готов к отправке"
```

### 2. Обновление всех DCA вызовов
**Решение**: Заменены все вызовы `should_send_signal` на `should_send_dca_signal` для DCA сигналов

#### DCA LONG сигналы:
```python
# Было:
should_send, reason = should_send_signal(df, current_index, "long", last['close'], user_id, symbol)

# Стало:
should_send, reason = should_send_dca_signal(df, current_index, "long", last['close'], user_id, symbol)
```

#### DCA SHORT сигналы:
```python
# Было:
should_send, reason = should_send_signal(df, current_index, "short", last['close'], user_id, symbol)

# Стало:
should_send, reason = should_send_dca_signal(df, current_index, "short", last['close'], user_id, symbol)
```

#### Накопленные DCA сигналы:
```python
# Было:
should_send, reason = should_send_signal(None, None, side, current_price, user_id, symbol)

# Стало:
should_send, reason = should_send_dca_signal(None, None, side, current_price, user_id, symbol)
```

## Новые строгие условия для DCA сигналов

### 1. **Увеличенный таймаут**
- **Было**: 5 минут (300 секунд)
- **Стало**: 30 минут (1800 секунд)

### 2. **Дополнительная проверка времени между DCA**
- **Минимальный интервал**: 30 минут между DCA сигналами
- **Проверка**: `last_dca_time` в позиции пользователя
- **Обновление**: Время последнего DCA записывается в позицию

### 3. **Более строгая точность**
- **Было**: tolerance = 0.001 (0.1%)
- **Стало**: tolerance = 0.005 (0.5%)

### 4. **Увеличенные требования к техническим условиям**
- **Было**: 70% условий
- **Стало**: 90% условий

### 5. **Проверка EMA20**
- **LONG DCA**: Цена должна быть ниже EMA20
- **SHORT DCA**: Цена должна быть выше EMA20

### 6. **Проверка волатильности**
- DCA не срабатывает при волатильности больше 5%
- Защита от слишком нестабильных условий

### 7. **Проверка минимального изменения цены**
- **Минимум**: 1% изменение цены для DCA
- **Цель**: DCA только при значительных движениях

### 8. **Проверка минимальной просадки**
- **Минимум**: 2% просадка для DCA
- **Цель**: DCA только при существенной просадке

### 9. **Специальный префикс кэша**
- DCA сигналы используют префикс `DCA_` в кэше
- Отдельная очистка старых DCA записей

## Результаты

### До исправления:
- DCA сигналы срабатывали слишком часто (каждые 6 минут)
- Использовали те же условия, что и новые торговые сигналы
- Не было проверок волатильности, EMA и изменения цены

### После исправления:
- ✅ **Очень редкие DCA сигналы** (таймаут 30 минут)
- ✅ **Минимальный интервал** (30 минут между DCA для одной позиции)
- ✅ **Очень строгие условия** (90% технических условий, проверка EMA20, волатильности)
- ✅ **Проверка изменения цены** (минимум 1% изменение)
- ✅ **Проверка просадки** (минимум 2% просадка)
- ✅ **Отдельная логика** для DCA сигналов
- ✅ **Защита от спама** (очень строгая точность)

## Логика работы

### 1. **Проверка таймаута**
- DCA сигналы не отправляются чаще чем раз в 30 минут

### 2. **Проверка интервала между DCA**
- Минимум 30 минут между DCA сигналами для одной позиции

### 3. **Проверка точности**
- Предотвращение дубликатов с точностью 0.5%

### 4. **Проверка технических условий**
- Требуется выполнение 90% технических условий

### 5. **Проверка EMA20**
- LONG DCA: только при цене ниже EMA20
- SHORT DCA: только при цене выше EMA20

### 6. **Проверка волатильности**
- DCA не срабатывает при волатильности > 5%

### 7. **Проверка изменения цены**
- DCA только при изменении цены >= 1%

### 8. **Проверка просадки**
- DCA только при просадке >= 2%

### 9. **Кэширование**
- Отдельный кэш для DCA сигналов с префиксом `DCA_`

## Заключение
Проблема с частыми DCA сигналами была успешно исправлена. Теперь DCA сигналы:

- ✅ **Срабатывают очень редко** (30 минут вместо 5)
- ✅ **Минимальный интервал** (30 минут между DCA для одной позиции)
- ✅ **Имеют очень строгие условия** (90% технических условий, EMA20, волатильность, изменение цены, просадка)
- ✅ **Используют отдельную логику** от торговых сигналов
- ✅ **Защищены от спама** (очень строгая точность)

**Статус**: ✅ Проблема решена - DCA сигналы теперь срабатывают с правильной частотой
