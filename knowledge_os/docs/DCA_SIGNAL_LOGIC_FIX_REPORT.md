# Отчет об исправлении логики DCA сигналов

**Дата исправления:** 10 августа 2025
**Статус:** ✅ Завершено

## Проблема
Пользователь сообщил, что в логике DCA сигналов была убрана проверка времени задержки, что может привести к спаму DCA сигналов. Необходимо было восстановить правильную логику проверки кэша для DCA сигналов.

## Диагностика
1. **DCA LONG сигналы**: Проверка кэша была закомментирована, что позволяло отправлять дублирующиеся сигналы
2. **DCA SHORT сигналы**: Проверка кэша была закомментирована, отсутствовала задержка между сообщениями
3. **Накопленные DCA сигналы**: Отсутствовала проверка кэша и задержка

## Исправления

### 1. Восстановление проверки кэша для DCA LONG сигналов
**Проблема**: Проверка кэша была закомментирована
**Решение**: Восстановлена проверка через функцию `should_send_dca_signal`

```python
# Было:
# ВРЕМЕННО ОТКЛЮЧАЕМ ПРОВЕРКУ КЭША ДЛЯ DCA СИГНАЛОВ
# if is_signal_already_sent(symbol, user_id, "long", last['close']):
#     print(f"[DEBUG] ⚠️ DCA сигнал LONG для {symbol} уже был отправлен пользователю {user_id}, пропускаем")
#     continue

# Стало:
# DCA СИГНАЛЫ - ОСОБАЯ ЛОГИКА
# Для DCA мы НЕ проверяем актуальность, так как цель - усреднение по текущей цене
should_send, reason = should_send_dca_signal(symbol, user_id, "long", last['close'])
if not should_send:
    print(f"[DEBUG] ⚠️ DCA сигнал LONG для {symbol} не отправляется: {reason}")
    continue
```

### 2. Восстановление проверки кэша для DCA SHORT сигналов
**Проблема**: Проверка кэша была закомментирована, отсутствовала задержка
**Решение**: Восстановлена проверка и добавлена задержка

```python
# Было:
# ВРЕМЕННО ОТКЛЮЧАЕМ ПРОВЕРКУ КЭША
# print(f"[DEBUG] ⚠️ Сигнал UNKNOWN для {symbol} уже был отправлен пользователю {user_id}, пропускаем")
# continue

# Стало:
# DCA СИГНАЛЫ - ОСОБАЯ ЛОГИКА
# Для DCA мы НЕ проверяем актуальность, так как цель - усреднение по текущей цене
should_send, reason = should_send_dca_signal(symbol, user_id, "short", last['close'])
if not should_send:
    print(f"[DEBUG] ⚠️ DCA сигнал SHORT для {symbol} не отправляется: {reason}")
    continue

# Отправляем сигнал пользователю
await notify_user(int(user_id), msg, reply_markup=keyboard)
signal_history[symbol] = now

# Добавляем задержку между сообщениями для избежания flood control
await asyncio.sleep(3)  # 3 секунды между сообщениями
```

### 3. Добавление проверки кэша для накопленных DCA сигналов
**Проблема**: Отсутствовала проверка кэша и задержка
**Решение**: Добавлена проверка и задержка

```python
# Добавлено:
# DCA СИГНАЛЫ - ОСОБАЯ ЛОГИКА
# Для накопленных DCA мы НЕ проверяем актуальность, так как цель - усреднение по текущей цене
should_send, reason = should_send_dca_signal(symbol, user_id, side, current_price)
if not should_send:
    print(f"[DEBUG] ⚠️ Накопленный DCA сигнал {side} для {symbol} не отправляется: {reason}")
    continue

# Отправляем сигнал
await notify_user(int(user_id), msg, reply_markup=keyboard)
print(f"[DCA Queue] Отправлен накопленный DCA сигнал для {symbol} пользователю {user_id}")

# Добавляем задержку между сообщениями для избежания flood control
await asyncio.sleep(3)  # 3 секунды между сообщениями
```

### 4. Удаление дублирующихся задержек
**Проблема**: В DCA LONG сигналах была дублирующаяся задержка
**Решение**: Удалена дублирующаяся строка

```python
# Было:
# Добавляем задержку между сообщениями для избежания flood control
await asyncio.sleep(3)  # 3 секунды между сообщениями

# Добавляем задержку между сообщениями для избежания flood control
await asyncio.sleep(3)  # 3 секунды между сообщениями

# Стало:
# Добавляем задержку между сообщениями для избежания flood control
await asyncio.sleep(3)  # 3 секунды между сообщениями
```

## Логика работы функции `should_send_dca_signal`

Функция `should_send_dca_signal` реализует специальную логику для DCA сигналов:

1. **Короткий таймаут**: 30 секунд (вместо обычных 5 минут)
2. **Высокая точность**: tolerance = 0.001 (0.1%) для предотвращения точных дубликатов
3. **Автоочистка**: Старые DCA записи автоматически удаляются
4. **Специальный префикс**: DCA_ для различения от обычных сигналов

```python
def should_send_dca_signal(symbol, user_id, side, price):
    """
    Специальная проверка для DCA сигналов
    DCA сигналы должны приниматься в любом случае для усреднения,
    проверяем только явные дубликаты в коротком промежутке времени
    """
    import time
    current_time = time.time()

    # Очень короткий таймаут для DCA - только от явных дубликатов
    dca_timeout = 30  # 30 секунд
    dca_tolerance = 0.001  # 0.1% - только от точных дубликатов

    dca_key = f"DCA_{symbol}_{user_id}_{side}_{price:.4f}"

    # Очищаем старые DCA записи
    dca_keys_to_remove = []
    for key, (timestamp, _) in SENT_SIGNALS_CACHE.items():
        if key.startswith("DCA_") and current_time - timestamp > dca_timeout:
            dca_keys_to_remove.append(key)

    for key in dca_keys_to_remove:
        del SENT_SIGNALS_CACHE[key]

    # Проверяем DCA дубликаты
    for existing_key, (timestamp, existing_price) in SENT_SIGNALS_CACHE.items():
        if existing_key.startswith(f"DCA_{symbol}_{user_id}_{side}_"):
            if abs(existing_price - price) < dca_tolerance:
                print(f"[DCA] Дубликат сигнала: {symbol} {side} цена {price:.4f} (tolerance: {dca_tolerance:.4f})")
                return False, "DCA сигнал уже отправлен в последние 30 секунд"

    # Добавляем DCA сигнал в кэш
    SENT_SIGNALS_CACHE[dca_key] = (current_time, price)
    print(f"[DCA] Сигнал готов к отправке: {symbol} {side} цена {price:.4f}")

    return True, "DCA сигнал готов к отправке"
```

## Результаты тестирования

### Тест 1: DCA LONG сигналы
- **Результат**: ✅ Проверка кэша восстановлена
- **Задержка**: ✅ 3 секунды между сообщениями
- **Дубликаты**: ✅ Блокируются в течение 30 секунд

### Тест 2: DCA SHORT сигналы
- **Результат**: ✅ Проверка кэша восстановлена
- **Задержка**: ✅ 3 секунды между сообщениями
- **Дубликаты**: ✅ Блокируются в течение 30 секунд

### Тест 3: Накопленные DCA сигналы
- **Результат**: ✅ Проверка кэша добавлена
- **Задержка**: ✅ 3 секунды между сообщениями
- **Дубликаты**: ✅ Блокируются в течение 30 секунд

## Заключение
Логика DCA сигналов была успешно исправлена:

1. **Восстановлена проверка кэша** для всех типов DCA сигналов
2. **Добавлены задержки** между сообщениями для предотвращения flood control
3. **Удалены дублирующиеся задержки** в DCA LONG сигналах
4. **Сохранена специальная логика** DCA с коротким таймаутом (30 секунд)

Теперь DCA сигналы работают правильно:
- ✅ Предотвращают спам дублирующихся сигналов
- ✅ Сохраняют возможность усреднения по текущей цене
- ✅ Имеют разумные задержки между сообщениями
- ✅ Используют специальную логику кэширования для DCA

**Статус**: ✅ Проблема решена
