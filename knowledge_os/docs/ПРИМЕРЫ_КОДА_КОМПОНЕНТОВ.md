# üìù –ü–†–ò–ú–ï–†–´ –ö–û–î–ê –ö–û–ú–ü–û–ù–ï–ù–¢–û–í –¢–û–†–ì–û–í–û–ì–û –ë–û–¢–ê

## üîß –û–°–ù–û–í–ù–´–ï –§–ê–ô–õ–´

### 1. requirements.txt
```txt
# –û—Å–Ω–æ–≤–Ω—ã–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏
pandas>=1.5.0
numpy>=1.21.0
requests>=2.28.0
aiohttp>=3.8.0
python-telegram-bot>=20.0
ta>=0.10.0
ccxt>=2.0.0
python-dotenv>=0.19.0
scikit-learn>=1.1.0
matplotlib>=3.5.0
redis>=4.0.0
```

### 2. .env
```env
# Telegram
TELEGRAM_TOKEN=your_bot_token_here
TELEGRAM_TOKEN_DEV=your_dev_token_here
TELEGRAM_CHAT_IDS=[123456789,987654321]

# API Keys
ETHERSCAN_API_KEY=your_key
BSCSCAN_API_KEY=your_key
CRYPTOPANIC_API_KEY=390212cf54403e087e19347f4f3e4a2f4459c79c
NEWSDATA_API_KEY=pub_9259f5b0818a4d40baabae05a908af4f
```

### 3. main.py
```python
#!/usr/bin/env python3
import asyncio
import logging
import signal
import sys
from telegram_bot import run_telegram_bot
from signal_live import run_signal_generation
from auto_optimizer import run_optimization

# –ù–∞—Å—Ç—Ä–æ–π–∫–∞ –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[
        logging.FileHandler('system.log'),
        logging.StreamHandler()
    ]
)

logger = logging.getLogger(__name__)

async def main():
    """–û—Å–Ω–æ–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –∑–∞–ø—É—Å–∫–∞"""
    logger.info("üöÄ –ó–∞–ø—É—Å–∫ —Ç–æ—Ä–≥–æ–≤–æ–π —Å–∏—Å—Ç–µ–º—ã ATRA...")

    try:
        # –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤ –ø–∞—Ä–∞–ª–ª–µ–ª—å–Ω–æ
        await asyncio.gather(
            run_telegram_bot(),
            run_signal_generation(),
            run_optimization()
        )
    except KeyboardInterrupt:
        logger.info("üõë –ü–æ–ª—É—á–µ–Ω —Å–∏–≥–Ω–∞–ª –æ—Å—Ç–∞–Ω–æ–≤–∫–∏")
    except Exception as e:
        logger.error(f"‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∞—è –æ—à–∏–±–∫–∞: {e}")
    finally:
        logger.info("‚úÖ –°–∏—Å—Ç–µ–º–∞ –æ—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∞")

if __name__ == "__main__":
    asyncio.run(main())
```

### 4. config.py
```python
import os
from dotenv import load_dotenv

load_dotenv()

# –û—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
DATABASE = "trading.db"
TELEGRAM_TOKEN = os.getenv("TELEGRAM_TOKEN")
TELEGRAM_TOKEN_DEV = os.getenv("TELEGRAM_TOKEN_DEV", "")
TELEGRAM_CHAT_IDS = os.getenv("TELEGRAM_CHAT_IDS")

# –§–∏–ª—å—Ç—Ä—ã —Ä–∏—Å–∫–∞
RISK_FILTERS = {
    "min_volume_24h": 50_000_000,
    "max_spread_pct": 2.0,
    "min_price": 0.01,
    "max_price": 100_000,
    "max_volatility_pct": 15.0,
    "min_profit_pct": 0.5,
    "max_profit_pct": 5.0,
    "enable_risk_filters": True,
}

# –ù–∞—Å—Ç—Ä–æ–π–∫–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
ENHANCED_STRATEGY_CONFIG = {
    "bb_window": 20,
    "bb_std": 2.0,
    "ema_fast": 12,
    "ema_slow": 39,
    "ema_trend": 50,
    "rsi_window": 14,
    "rsi_overbought": 90,
    "rsi_oversold": 10,
    "atr_window": 15,
    "atr_multiplier_sl": 1.7,
}

# –ù–æ–≤–æ—Å—Ç–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã
NEWS_FILTER_MODES = {
    "conservative": {
        "block_short_on_positive": True,
        "block_long_on_negative": True,
        "enhance_long_on_positive": True,
        "enhance_short_on_negative": True,
    },
    "soft": {
        "block_short_on_positive": False,
        "block_long_on_negative": False,
        "enhance_long_on_positive": False,
        "enhance_short_on_negative": False,
    },
    "aggressive": {
        "block_short_on_positive": False,
        "block_long_on_negative": False,
        "enhance_long_on_positive": True,
        "enhance_short_on_negative": True,
    }
}
```

## ü§ñ TELEGRAM –ë–û–¢

### telegram_bot.py
```python
import logging
import asyncio
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup
from telegram.ext import Application, CommandHandler, CallbackQueryHandler, ContextTypes
from config import TELEGRAM_TOKEN
from db import Database
import json

logger = logging.getLogger(__name__)
db = Database()

class TradingBot:
    def __init__(self):
        self.app = Application.builder().token(TELEGRAM_TOKEN).build()
        self.setup_handlers()
        self.user_data = {}

    def setup_handlers(self):
        """–ù–∞—Å—Ç—Ä–æ–π–∫–∞ –æ–±—Ä–∞–±–æ—Ç—á–∏–∫–æ–≤ –∫–æ–º–∞–Ω–¥"""
        self.app.add_handler(CommandHandler("start", self.start_command))
        self.app.add_handler(CommandHandler("balance", self.balance_command))
        self.app.add_handler(CommandHandler("deposit", self.deposit_command))
        self.app.add_handler(CommandHandler("positions", self.positions_command))
        self.app.add_handler(CommandHandler("settings", self.settings_command))
        self.app.add_handler(CallbackQueryHandler(self.button_handler))

    async def start_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–æ–º–∞–Ω–¥—ã /start"""
        user_id = update.effective_user.id
        username = update.effective_user.username

        # –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        if str(user_id) not in self.user_data:
            self.user_data[str(user_id)] = {
                "username": username,
                "deposit": 0,
                "balance": 0,
                "filter_mode": "soft",
                "trade_mode": "spot",
                "news_filter_mode": "soft"
            }

        keyboard = [
            [InlineKeyboardButton("üí∞ –ë–∞–ª–∞–Ω—Å", callback_data="balance")],
            [InlineKeyboardButton("‚öôÔ∏è –ù–∞—Å—Ç—Ä–æ–π–∫–∏", callback_data="settings")],
            [InlineKeyboardButton("üìä –û—Ç—á–µ—Ç", callback_data="report")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await update.message.reply_text(
            f"üöÄ –î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å –≤ —Ç–æ—Ä–≥–æ–≤—É—é —Å–∏—Å—Ç–µ–º—É ATRA!\n"
            f"–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å: @{username}\n"
            f"–í—ã–±–µ—Ä–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏–µ:",
            reply_markup=reply_markup
        )

    async def balance_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–ü–æ–∫–∞–∑–∞—Ç—å –±–∞–ª–∞–Ω—Å"""
        user_id = str(update.effective_user.id)
        user_data = self.user_data.get(user_id, {})

        balance = user_data.get("balance", 0)
        deposit = user_data.get("deposit", 0)

        await update.message.reply_text(
            f"üí∞ –ë–ê–õ–ê–ù–°\n\n"
            f"–î–µ–ø–æ–∑–∏—Ç: {deposit:.2f} USDT\n"
            f"–¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {balance:.2f} USDT\n"
            f"–ü—Ä–∏–±—ã–ª—å: {balance - deposit:.2f} USDT"
        )

    async def deposit_command(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–£—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –¥–µ–ø–æ–∑–∏—Ç"""
        user_id = str(update.effective_user.id)

        if not context.args:
            await update.message.reply_text(
                "üí≥ –£–∫–∞–∂–∏—Ç–µ —Å—É–º–º—É –¥–µ–ø–æ–∑–∏—Ç–∞:\n"
                "/deposit <—Å—É–º–º–∞>"
            )
            return

        try:
            amount = float(context.args[0])
            if amount <= 0:
                raise ValueError("–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π")

            if user_id not in self.user_data:
                self.user_data[user_id] = {}

            self.user_data[user_id]["deposit"] = amount
            self.user_data[user_id]["balance"] = amount

            await update.message.reply_text(
                f"‚úÖ –î–µ–ø–æ–∑–∏—Ç —É—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω: {amount:.2f} USDT"
            )

        except ValueError as e:
            await update.message.reply_text(f"‚ùå –û—à–∏–±–∫–∞: {e}")

    async def button_handler(self, update: Update, context: ContextTypes.DEFAULT_TYPE):
        """–û–±—Ä–∞–±–æ—Ç–∫–∞ –∫–Ω–æ–ø–æ–∫"""
        query = update.callback_query
        await query.answer()

        if query.data == "balance":
            user_id = str(query.from_user.id)
            user_data = self.user_data.get(user_id, {})
            balance = user_data.get("balance", 0)
            deposit = user_data.get("deposit", 0)

            await query.edit_message_text(
                f"üí∞ –ë–ê–õ–ê–ù–°\n\n"
                f"–î–µ–ø–æ–∑–∏—Ç: {deposit:.2f} USDT\n"
                f"–¢–µ–∫—É—â–∏–π –±–∞–ª–∞–Ω—Å: {balance:.2f} USDT\n"
                f"–ü—Ä–∏–±—ã–ª—å: {balance - deposit:.2f} USDT"
            )

        elif query.data == "settings":
            await self.show_settings(query)

        elif query.data.startswith("accept_"):
            await self.accept_signal(query)

        elif query.data.startswith("decline_"):
            await self.decline_signal(query)

    async def show_settings(self, query):
        """–ü–æ–∫–∞–∑–∞—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏"""
        user_id = str(query.from_user.id)
        user_data = self.user_data.get(user_id, {})

        keyboard = [
            [InlineKeyboardButton("üîß –†–µ–∂–∏–º —Ñ–∏–ª—å—Ç—Ä–æ–≤", callback_data="filter_mode")],
            [InlineKeyboardButton("üì∞ –ù–æ–≤–æ—Å—Ç–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã", callback_data="news_mode")],
            [InlineKeyboardButton("üíº –†–µ–∂–∏–º —Ç–æ—Ä–≥–æ–≤–ª–∏", callback_data="trade_mode")]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        await query.edit_message_text(
            f"‚öôÔ∏è –ù–ê–°–¢–†–û–ô–ö–ò\n\n"
            f"–†–µ–∂–∏–º —Ñ–∏–ª—å—Ç—Ä–æ–≤: {user_data.get('filter_mode', 'soft')}\n"
            f"–ù–æ–≤–æ—Å—Ç–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã: {user_data.get('news_filter_mode', 'soft')}\n"
            f"–†–µ–∂–∏–º —Ç–æ—Ä–≥–æ–≤–ª–∏: {user_data.get('trade_mode', 'spot')}",
            reply_markup=reply_markup
        )

    async def accept_signal(self, query):
        """–ü—Ä–∏–Ω—è—Ç—å —Å–∏–≥–Ω–∞–ª"""
        signal_data = query.data.replace("accept_", "")
        user_id = str(query.from_user.id)

        # –õ–æ–≥–∏–∫–∞ –ø—Ä–∏–Ω—è—Ç–∏—è —Å–∏–≥–Ω–∞–ª–∞
        await query.edit_message_text(
            f"‚úÖ –°–∏–≥–Ω–∞–ª –ø—Ä–∏–Ω—è—Ç!\n"
            f"–î–∞–Ω–Ω—ã–µ: {signal_data}"
        )

    async def decline_signal(self, query):
        """–û—Ç–∫–ª–æ–Ω–∏—Ç—å —Å–∏–≥–Ω–∞–ª"""
        signal_data = query.data.replace("decline_", "")

        await query.edit_message_text(
            f"‚ùå –°–∏–≥–Ω–∞–ª –æ—Ç–∫–ª–æ–Ω–µ–Ω\n"
            f"–î–∞–Ω–Ω—ã–µ: {signal_data}"
        )

async def run_telegram_bot():
    """–ó–∞–ø—É—Å–∫ Telegram –±–æ—Ç–∞"""
    bot = TradingBot()
    await bot.app.initialize()
    await bot.app.start()
    await bot.app.run_polling()
```

## üìä –°–ò–°–¢–ï–ú–ê –°–ò–ì–ù–ê–õ–û–í

### signal_live.py
```python
import asyncio
import pandas as pd
import ta
import logging
from datetime import datetime
from exchange_api import BinanceAPI
from config import ENHANCED_STRATEGY_CONFIG, RISK_FILTERS
from telegram_bot import notify_users

logger = logging.getLogger(__name__)

class SignalGenerator:
    def __init__(self):
        self.binance_api = BinanceAPI()
        self.sent_signals = set()

    def add_indicators(self, df):
        """–î–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–µ—Ö–Ω–∏—á–µ—Å–∫–∏—Ö –∏–Ω–¥–∏–∫–∞—Ç–æ—Ä–æ–≤"""
        # Bollinger Bands
        bb = ta.volatility.BollingerBands(
            df['close'],
            window=ENHANCED_STRATEGY_CONFIG['bb_window'],
            window_dev=ENHANCED_STRATEGY_CONFIG['bb_std']
        )
        df['bb_upper'] = bb.bollinger_hband()
        df['bb_middle'] = bb.bollinger_mavg()
        df['bb_lower'] = bb.bollinger_lband()

        # EMA
        df['ema_fast'] = ta.trend.EMAIndicator(
            df['close'],
            window=ENHANCED_STRATEGY_CONFIG['ema_fast']
        ).ema_indicator()
        df['ema_slow'] = ta.trend.EMAIndicator(
            df['close'],
            window=ENHANCED_STRATEGY_CONFIG['ema_slow']
        ).ema_indicator()

        # RSI
        df['rsi'] = ta.momentum.RSIIndicator(
            df['close'],
            window=ENHANCED_STRATEGY_CONFIG['rsi_window']
        ).rsi()

        # ATR
        df['atr'] = ta.volatility.AverageTrueRange(
            df['high'],
            df['low'],
            df['close'],
            window=ENHANCED_STRATEGY_CONFIG['atr_window']
        ).average_true_range()

        return df

    def breakout_strategy(self, df):
        """–°—Ç—Ä–∞—Ç–µ–≥–∏—è –ø—Ä–æ–±–æ—è –ø–æ–ª–æ—Å –ë–æ–ª–ª–∏–Ω–¥–∂–µ—Ä–∞"""
        if len(df) < 20:
            return None

        current = df.iloc[-1]
        prev = df.iloc[-2]

        # LONG —Å–∏–≥–Ω–∞–ª
        if (current['close'] > current['bb_upper'] and
            current['volume'] > df['volume'].rolling(20).mean().iloc[-1] and
            current['ema_fast'] > current['ema_slow']):
            return "LONG"

        # SHORT —Å–∏–≥–Ω–∞–ª
        if (current['close'] < current['bb_lower'] and
            current['volume'] > df['volume'].rolling(20).mean().iloc[-1] and
            current['ema_fast'] < current['ema_slow']):
            return "SHORT"

        return None

    def mean_reversion_strategy(self, df):
        """–°—Ç—Ä–∞—Ç–µ–≥–∏—è –≤–æ–∑–≤—Ä–∞—Ç–∞ –∫ —Å—Ä–µ–¥–Ω–µ–π"""
        if len(df) < 20:
            return None

        current = df.iloc[-1]

        # LONG —Å–∏–≥–Ω–∞–ª
        if (current['close'] < current['bb_middle'] and
            current['rsi'] < ENHANCED_STRATEGY_CONFIG['rsi_oversold']):
            return "LONG"

        # SHORT —Å–∏–≥–Ω–∞–ª
        if (current['close'] > current['bb_middle'] and
            current['rsi'] > ENHANCED_STRATEGY_CONFIG['rsi_overbought']):
            return "SHORT"

        return None

    def calculate_tp_sl(self, df, signal_type, entry_price):
        """–†–∞—Å—á–µ—Ç take profit –∏ stop loss"""
        atr = df['atr'].iloc[-1]

        if signal_type == "LONG":
            tp1 = entry_price + (atr * 1.5)
            tp2 = entry_price + (atr * 3.0)
            sl = entry_price - (atr * ENHANCED_STRATEGY_CONFIG['atr_multiplier_sl'])
        else:  # SHORT
            tp1 = entry_price - (atr * 1.5)
            tp2 = entry_price - (atr * 3.0)
            sl = entry_price + (atr * ENHANCED_STRATEGY_CONFIG['atr_multiplier_sl'])

        return tp1, tp2, sl

    async def get_top_symbols(self, limit=50):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ–ø —Å–∏–º–≤–æ–ª–æ–≤ –ø–æ –æ–±—ä–µ–º—É"""
        try:
            # –ü–æ–ª—É—á–∞–µ–º –≤—Å–µ USDT –ø–∞—Ä—ã
            tickers = await self.binance_api.get_tickers()

            # –§–∏–ª—å—Ç—Ä—É–µ–º –ø–æ –æ–±—ä–µ–º—É
            filtered = []
            for ticker in tickers:
                if (ticker['symbol'].endswith('USDT') and
                    float(ticker['volume']) * float(ticker['price']) > RISK_FILTERS['min_volume_24h']):
                    filtered.append(ticker['symbol'])

            return filtered[:limit]
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–∏–º–≤–æ–ª–æ–≤: {e}")
            return ["BTCUSDT", "ETHUSDT", "BNBUSDT", "SOLUSDT", "ADAUSDT"]

    async def generate_signals(self):
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–æ—Ä–≥–æ–≤—ã—Ö —Å–∏–≥–Ω–∞–ª–æ–≤"""
        symbols = await self.get_top_symbols()
        signals = []

        for symbol in symbols:
            try:
                # –ü–æ–ª—É—á–∞–µ–º OHLC –¥–∞–Ω–Ω—ã–µ
                ohlc_data = await self.binance_api.get_ohlc(symbol, interval="1h", limit=300)
                if not ohlc_data or len(ohlc_data) < 100:
                    continue

                # –°–æ–∑–¥–∞–µ–º DataFrame
                df = pd.DataFrame(ohlc_data)
                df = self.add_indicators(df)

                # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏
                signal_type = self.breakout_strategy(df)
                if not signal_type:
                    signal_type = self.mean_reversion_strategy(df)

                if signal_type:
                    entry_price = float(df['close'].iloc[-1])
                    tp1, tp2, sl = self.calculate_tp_sl(df, signal_type, entry_price)

                    signal = {
                        'symbol': symbol,
                        'type': signal_type,
                        'entry_price': entry_price,
                        'tp1': tp1,
                        'tp2': tp2,
                        'sl': sl,
                        'timestamp': datetime.now().isoformat(),
                        'volume': float(df['volume'].iloc[-1]),
                        'rsi': float(df['rsi'].iloc[-1]),
                        'atr': float(df['atr'].iloc[-1])
                    }

                    signals.append(signal)

            except Exception as e:
                logger.error(f"–û—à–∏–±–∫–∞ –∞–Ω–∞–ª–∏–∑–∞ {symbol}: {e}")
                continue

        return signals

    async def send_signal_notification(self, signal):
        """–û—Ç–ø—Ä–∞–≤–∫–∞ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏—è –æ —Å–∏–≥–Ω–∞–ª–µ"""
        signal_key = f"{signal['symbol']}_{signal['type']}_{signal['timestamp']}"

        if signal_key in self.sent_signals:
            return

        message = f"""
üéØ –ù–û–í–´–ô –°–ò–ì–ù–ê–õ {signal['type']}

üìä {signal['symbol']}
üí∞ –¶–µ–Ω–∞ –≤—Ö–æ–¥–∞: {signal['entry_price']:.6f}
üéØ TP1: {signal['tp1']:.6f}
üéØ TP2: {signal['tp2']:.6f}
üõë SL: {signal['sl']:.6f}

üìà RSI: {signal['rsi']:.1f}
üìä ATR: {signal['atr']:.6f}
üìÖ {signal['timestamp']}
        """

        keyboard = [
            [
                InlineKeyboardButton("‚úÖ –ü—Ä–∏–Ω—è—Ç—å", callback_data=f"accept_{signal_key}"),
                InlineKeyboardButton("‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", callback_data=f"decline_{signal_key}")
            ]
        ]
        reply_markup = InlineKeyboardMarkup(keyboard)

        # –û—Ç–ø—Ä–∞–≤–ª—è–µ–º –≤—Å–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è–º
        await notify_users(message, reply_markup)
        self.sent_signals.add(signal_key)

async def run_signal_generation():
    """–ó–∞–ø—É—Å–∫ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤"""
    generator = SignalGenerator()

    while True:
        try:
            logger.info("üîç –ü–æ–∏—Å–∫ —Å–∏–≥–Ω–∞–ª–æ–≤...")
            signals = await generator.generate_signals()

            for signal in signals:
                await generator.send_signal_notification(signal)

            logger.info(f"‚úÖ –ù–∞–π–¥–µ–Ω–æ —Å–∏–≥–Ω–∞–ª–æ–≤: {len(signals)}")

            # –ñ–¥–µ–º 5 –º–∏–Ω—É—Ç –ø–µ—Ä–µ–¥ —Å–ª–µ–¥—É—é—â–µ–π –ø—Ä–æ–≤–µ—Ä–∫–æ–π
            await asyncio.sleep(300)

        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –≥–µ–Ω–µ—Ä–∞—Ü–∏–∏ —Å–∏–≥–Ω–∞–ª–æ–≤: {e}")
            await asyncio.sleep(60)
```

## üóÑÔ∏è –ë–ê–ó–ê –î–ê–ù–ù–´–•

### db.py
```python
import sqlite3
import logging
import json
from datetime import datetime
from config import DATABASE

logger = logging.getLogger(__name__)

class Database:
    def __init__(self, db_path=DATABASE):
        self.db_path = db_path
        self.conn = sqlite3.connect(db_path)
        self.cursor = self.conn.cursor()
        self.init_tables()

    def init_tables(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Ç–∞–±–ª–∏—Ü"""
        # –¢–∞–±–ª–∏—Ü–∞ —Å–∏–≥–Ω–∞–ª–æ–≤
        self.cursor.execute("""
            CREATE TABLE IF NOT EXISTS signals (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                symbol TEXT NOT NULL,
                signal_type TEXT NOT NULL,
                entry_price REAL NOT NULL,
                tp1 REAL NOT NULL,
                tp2 REAL NOT NULL,
                sl REAL NOT NULL,
                volume REAL,
                rsi REAL,
                atr REAL,
                status TEXT DEFAULT 'active',
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        """)

        # –¢–∞–±–ª–∏—Ü–∞ —Å–¥–µ–ª–æ–∫
        self.cursor.execute("""
            CREATE TABLE IF NOT EXISTS trades (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                signal_id INTEGER,
                user_id INTEGER,
                symbol TEXT NOT NULL,
                side TEXT NOT NULL,
                entry_price REAL NOT NULL,
                exit_price REAL,
                quantity REAL NOT NULL,
                profit REAL,
                status TEXT DEFAULT 'open',
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                closed_at DATETIME,
                FOREIGN KEY (signal_id) REFERENCES signals (id)
            )
        """)

        # –¢–∞–±–ª–∏—Ü–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π
        self.cursor.execute("""
            CREATE TABLE IF NOT EXISTS users (
                id INTEGER PRIMARY KEY,
                username TEXT,
                deposit REAL DEFAULT 0,
                balance REAL DEFAULT 0,
                filter_mode TEXT DEFAULT 'soft',
                trade_mode TEXT DEFAULT 'spot',
                news_filter_mode TEXT DEFAULT 'soft',
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP,
                updated_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        """)

        # –¢–∞–±–ª–∏—Ü–∞ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏
        self.cursor.execute("""
            CREATE TABLE IF NOT EXISTS statistics (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                date TEXT NOT NULL,
                signals_count INTEGER DEFAULT 0,
                trades_count INTEGER DEFAULT 0,
                profitable_trades INTEGER DEFAULT 0,
                total_profit REAL DEFAULT 0,
                win_rate REAL DEFAULT 0,
                created_at DATETIME DEFAULT CURRENT_TIMESTAMP
            )
        """)

        self.conn.commit()

    def save_signal(self, signal_data):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞"""
        try:
            self.cursor.execute("""
                INSERT INTO signals (symbol, signal_type, entry_price, tp1, tp2, sl, volume, rsi, atr)
                VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
            """, (
                signal_data['symbol'],
                signal_data['type'],
                signal_data['entry_price'],
                signal_data['tp1'],
                signal_data['tp2'],
                signal_data['sl'],
                signal_data.get('volume', 0),
                signal_data.get('rsi', 0),
                signal_data.get('atr', 0)
            ))
            self.conn.commit()
            return self.cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–∏–≥–Ω–∞–ª–∞: {e}")
            return None

    def save_trade(self, trade_data):
        """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ —Å–¥–µ–ª–∫–∏"""
        try:
            self.cursor.execute("""
                INSERT INTO trades (signal_id, user_id, symbol, side, entry_price, quantity)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (
                trade_data.get('signal_id'),
                trade_data['user_id'],
                trade_data['symbol'],
                trade_data['side'],
                trade_data['entry_price'],
                trade_data['quantity']
            ))
            self.conn.commit()
            return self.cursor.lastrowid
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Å–¥–µ–ª–∫–∏: {e}")
            return None

    def close_trade(self, trade_id, exit_price, profit):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ —Å–¥–µ–ª–∫–∏"""
        try:
            self.cursor.execute("""
                UPDATE trades
                SET exit_price = ?, profit = ?, status = 'closed', closed_at = CURRENT_TIMESTAMP
                WHERE id = ?
            """, (exit_price, profit, trade_id))
            self.conn.commit()
            return True
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–∫—Ä—ã—Ç–∏—è —Å–¥–µ–ª–∫–∏: {e}")
            return False

    def get_user_trades(self, user_id, limit=50):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–¥–µ–ª–æ–∫ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è"""
        try:
            self.cursor.execute("""
                SELECT * FROM trades
                WHERE user_id = ?
                ORDER BY created_at DESC
                LIMIT ?
            """, (user_id, limit))
            return self.cursor.fetchall()
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å–¥–µ–ª–æ–∫: {e}")
            return []

    def get_daily_stats(self, date):
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –¥–Ω–µ–≤–Ω–æ–π —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏"""
        try:
            self.cursor.execute("""
                SELECT
                    COUNT(*) as signals_count,
                    (SELECT COUNT(*) FROM trades WHERE DATE(created_at) = ?) as trades_count,
                    (SELECT COUNT(*) FROM trades WHERE DATE(created_at) = ? AND profit > 0) as profitable_trades,
                    (SELECT COALESCE(SUM(profit), 0) FROM trades WHERE DATE(created_at) = ?) as total_profit
                FROM signals
                WHERE DATE(created_at) = ?
            """, (date, date, date, date))

            result = self.cursor.fetchone()
            if result:
                signals_count, trades_count, profitable_trades, total_profit = result
                win_rate = (profitable_trades / trades_count * 100) if trades_count > 0 else 0

                return {
                    'signals_count': signals_count,
                    'trades_count': trades_count,
                    'profitable_trades': profitable_trades,
                    'total_profit': total_profit,
                    'win_rate': win_rate
                }
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏: {e}")

        return {
            'signals_count': 0,
            'trades_count': 0,
            'profitable_trades': 0,
            'total_profit': 0,
            'win_rate': 0
        }

    def __del__(self):
        """–ó–∞–∫—Ä—ã—Ç–∏–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è"""
        if hasattr(self, 'conn'):
            self.conn.close()
```

## üîå API –ò–ù–¢–ï–ì–†–ê–¶–ò–ò

### exchange_api.py
```python
import aiohttp
import asyncio
import logging
from typing import List, Dict, Optional

logger = logging.getLogger(__name__)

class BinanceAPI:
    BASE_URL = "https://api.binance.com"

    @staticmethod
    async def get_ohlc(symbol: str, interval: str = "1h", limit: int = 300) -> Optional[List[Dict]]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ OHLC –¥–∞–Ω–Ω—ã—Ö"""
        url = f"{BinanceAPI.BASE_URL}/api/v3/klines"
        params = {
            "symbol": symbol,
            "interval": interval,
            "limit": limit
        }

        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params, timeout=30) as response:
                    if response.status == 200:
                        data = await response.json()
                        return [
                            {
                                "timestamp": int(item[0]),
                                "open": float(item[1]),
                                "high": float(item[2]),
                                "low": float(item[3]),
                                "close": float(item[4]),
                                "volume": float(item[5])
                            }
                            for item in data
                        ]
                    else:
                        logger.error(f"HTTP {response.status} –¥–ª—è {symbol}")
                        return None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è OHLC –¥–ª—è {symbol}: {e}")
            return None

    @staticmethod
    async def get_tickers() -> List[Dict]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –≤—Å–µ—Ö —Ç–∏–∫–µ—Ä–æ–≤"""
        url = f"{BinanceAPI.BASE_URL}/api/v3/ticker/24hr"

        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, timeout=30) as response:
                    if response.status == 200:
                        data = await response.json()
                        return [
                            {
                                "symbol": item["symbol"],
                                "price": float(item["lastPrice"]),
                                "volume": float(item["volume"]),
                                "quoteVolume": float(item["quoteVolume"]),
                                "priceChange": float(item["priceChange"]),
                                "priceChangePercent": float(item["priceChangePercent"])
                            }
                            for item in data
                        ]
                    else:
                        logger.error(f"HTTP {response.status} –¥–ª—è –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–∏–∫–µ—Ä–æ–≤")
                        return []
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ç–∏–∫–µ—Ä–æ–≤: {e}")
            return []

    @staticmethod
    async def get_price(symbol: str) -> Optional[float]:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–π —Ü–µ–Ω—ã"""
        url = f"{BinanceAPI.BASE_URL}/api/v3/ticker/price"
        params = {"symbol": symbol}

        try:
            async with aiohttp.ClientSession() as session:
                async with session.get(url, params=params, timeout=10) as response:
                    if response.status == 200:
                        data = await response.json()
                        return float(data["price"])
                    else:
                        logger.error(f"HTTP {response.status} –¥–ª—è {symbol}")
                        return None
        except Exception as e:
            logger.error(f"–û—à–∏–±–∫–∞ –ø–æ–ª—É—á–µ–Ω–∏—è —Ü–µ–Ω—ã –¥–ª—è {symbol}: {e}")
            return None

    @staticmethod
    def get_symbol_precision(symbol: str) -> int:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–æ—á–Ω–æ—Å—Ç–∏ —Å–∏–º–≤–æ–ª–∞"""
        precision_map = {
            'BTCUSDT': 2, 'ETHUSDT': 2, 'BNBUSDT': 2,
            'SOLUSDT': 3, 'ADAUSDT': 4, 'XRPUSDT': 4,
            'DOGEUSDT': 6, 'SHIBUSDT': 6, 'PEPEUSDT': 6
        }
        return precision_map.get(symbol, 5)
```

## üìä –£–¢–ò–õ–ò–¢–´

### shared_utils.py
```python
import logging
import json
import os
from typing import Dict, Any
from datetime import datetime

logger = logging.getLogger(__name__)

def load_user_data() -> Dict[str, Any]:
    """–ó–∞–≥—Ä—É–∑–∫–∞ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
    try:
        if os.path.exists("user_data.json"):
            with open("user_data.json", "r", encoding="utf-8") as f:
                return json.load(f)
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")

    return {}

def save_user_data(user_data: Dict[str, Any]) -> bool:
    """–°–æ—Ö—Ä–∞–Ω–µ–Ω–∏–µ –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π"""
    try:
        with open("user_data.json", "w", encoding="utf-8") as f:
            json.dump(user_data, f, ensure_ascii=False, indent=2)
        return True
    except Exception as e:
        logger.error(f"–û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è –¥–∞–Ω–Ω—ã—Ö –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: {e}")
        return False

def format_price(price: float, symbol: str) -> str:
    """–§–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ —Ü–µ–Ω—ã"""
    try:
        from exchange_api import BinanceAPI
        precision = BinanceAPI.get_symbol_precision(symbol)
        return f"{price:.{precision}f}"
    except:
        return f"{price:.5f}"

def calculate_profit_percentage(entry_price: float, exit_price: float, side: str) -> float:
    """–†–∞—Å—á–µ—Ç –ø—Ä–æ—Ü–µ–Ω—Ç–∞ –ø—Ä–∏–±—ã–ª–∏"""
    if side.upper() == "LONG":
        return ((exit_price - entry_price) / entry_price) * 100
    else:  # SHORT
        return ((entry_price - exit_price) / entry_price) * 100

def validate_signal(signal_data: Dict[str, Any]) -> bool:
    """–í–∞–ª–∏–¥–∞—Ü–∏—è —Å–∏–≥–Ω–∞–ª–∞"""
    required_fields = ['symbol', 'type', 'entry_price', 'tp1', 'tp2', 'sl']

    for field in required_fields:
        if field not in signal_data:
            logger.error(f"–û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –ø–æ–ª–µ: {field}")
            return False

    if signal_data['entry_price'] <= 0:
        logger.error("–¶–µ–Ω–∞ –≤—Ö–æ–¥–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –ø–æ–ª–æ–∂–∏—Ç–µ–ª—å–Ω–æ–π")
        return False

    if signal_data['type'] not in ['LONG', 'SHORT']:
        logger.error("–¢–∏–ø —Å–∏–≥–Ω–∞–ª–∞ –¥–æ–ª–∂–µ–Ω –±—ã—Ç—å LONG –∏–ª–∏ SHORT")
        return False

    return True

def get_current_time() -> str:
    """–ü–æ–ª—É—á–µ–Ω–∏–µ —Ç–µ–∫—É—â–µ–≥–æ –≤—Ä–µ–º–µ–Ω–∏"""
    return datetime.now().strftime("%Y-%m-%d %H:%M:%S")

def log_signal(signal_data: Dict[str, Any]):
    """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–∏–≥–Ω–∞–ª–∞"""
    logger.info(f"üéØ –°–ò–ì–ù–ê–õ: {signal_data['symbol']} {signal_data['type']} "
                f"@ {format_price(signal_data['entry_price'], signal_data['symbol'])}")

def log_trade(trade_data: Dict[str, Any]):
    """–õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–¥–µ–ª–∫–∏"""
    logger.info(f"üí∞ –°–î–ï–õ–ö–ê: {trade_data['symbol']} {trade_data['side']} "
                f"@ {format_price(trade_data['entry_price'], trade_data['symbol'])}")
```

## üöÄ –ó–ê–ü–£–°–ö –°–ò–°–¢–ï–ú–´

### –ó–∞–ø—É—Å–∫ –≤—Å–µ—Ö –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤:
```bash
# 1. –ê–∫—Ç–∏–≤–∞—Ü–∏—è –≤–∏—Ä—Ç—É–∞–ª—å–Ω–æ–≥–æ –æ–∫—Ä—É–∂–µ–Ω–∏—è
source venv/bin/activate

# 2. –£—Å—Ç–∞–Ω–æ–≤–∫–∞ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–µ–π
pip install -r requirements.txt

# 3. –°–æ–∑–¥–∞–Ω–∏–µ .env —Ñ–∞–π–ª–∞
cp .env.example .env
# –û—Ç—Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å .env —Å –≤–∞—à–∏–º–∏ —Ç–æ–∫–µ–Ω–∞–º–∏

# 4. –ó–∞–ø—É—Å–∫ —Å–∏—Å—Ç–µ–º—ã
python main.py
```

### –ú–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥:
```bash
# –ü—Ä–æ—Å–º–æ—Ç—Ä –ª–æ–≥–æ–≤
tail -f system.log

# –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å—Ç–∞—Ç—É—Å–∞
ps aux | grep python

# –ü—Ä–æ–≤–µ—Ä–∫–∞ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
sqlite3 trading.db ".tables"
```

–≠—Ç–æ—Ç –∫–æ–¥ –ø—Ä–µ–¥–æ—Å—Ç–∞–≤–ª—è–µ—Ç –ø–æ–ª–Ω—É—é –æ—Å–Ω–æ–≤—É –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è —Ç–æ—Ä–≥–æ–≤–æ–≥–æ –±–æ—Ç–∞ —Å –Ω—É–ª—è. –í—Å–µ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç—ã –≥–æ—Ç–æ–≤—ã –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é –∏ –º–æ–≥—É—Ç –±—ã—Ç—å –ª–µ–≥–∫–æ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã –ø–æ–¥ –≤–∞—à–∏ –ø–æ—Ç—Ä–µ–±–Ω–æ—Å—Ç–∏.
