# Знания → код и улучшения: дизайн (мировые практики)

**Статус:** реализовано в Singularity 10.0  
**Ссылки:** ExpeL (AAAI 2024), BCG 10/20/70, closed-loop learning

---

## Цель

Замкнуть цикл: обучение и ретроспективы не только попадают в правила и БД, но и **влияют на код** через явные задачи и контекст при выполнении.

---

## Мировые практики

### ExpeL (Experiential Learning, AAAI 2024)

- **Experience gathering** — успешные и неуспешные траектории.
- **Knowledge extraction** — извлечение инсайтов (ADD/UPVOTE/DOWNVOTE/EDIT), паттерны успеха/провала.
- **Task inference** — при решении новой задачи агент **вспоминает** извлечённые инсайты и успешные траектории (recall at inference).

У нас:
- Опыт → `adaptive_learning_logs`, `knowledge_nodes`, ретроспективы в БД.
- Извлечение → lessons в .cursorrules, код-релевантные инсайты → задачи «Внедрить в код».
- Inference → при выполнении задачи воркер подтягивает релевантные знания по домену эксперта и добавляет их в промпт (recall at inference).

### BCG 10/20/70

- 10% — обучение (курсы, материалы).
- 20% — обмен (дебаты, советы экспертов, ретроспективы).
- 70% — практика (реальные задачи).

У нас: уроки и инсайты попадают в **правила** (.cursorrules) и в **задачи на внедрение**; воркер при решении задачи получает релевантные знания в контексте → практика подкреплена контекстом из 10% и 20%.

### Closed-loop

- Ретроспективы и фидбек → `knowledge_nodes`.
- Lessons → .cursorrules + при код-релевантности → задачи «Внедрить в код».
- При выполнении задачи — подтяжка знаний по домену (ExpeL-style recall).

---

## Реализация

| Компонент | Где | Что делает |
|-----------|-----|------------|
| **Knowledge Applicator** | `observability/knowledge_applicator.py` | Lessons → .cursorrules; ретроспективы → knowledge_nodes; инсайты → задачи на эволюцию промптов; **код-релевантные уроки/инсайты → задачи «Внедрить в код»** (до 3 из lessons, до 5 из knowledge_nodes, без дубликатов). |
| **Smart Worker** | `app/smart_worker_autonomous.py` | Перед сборкой промпта запрашивает **топ-5 knowledge_nodes** по домену эксперта (is_verified или confidence > 0.75), добавляет блок «RELEVANT KNOWLEDGE (use when solving)» в промпт. |
| **Enhanced Expert Evolver** | Фаза 7 ночного цикла | Обрабатывает задачи «Prompt evolution from top insights»: подхватывает инсайты из описания задачи, вызывает LLM для обновления промпта 1–3 экспертов, обновляет `experts.system_prompt`, помечает задачу выполненной. Тем самым эволюция промптов по инсайтам делается **автоматически**, а не только человеком. |
| **Nightly Learner** | Фаза 11 | Вызывает `apply_all_knowledge_async()`, логирует в т.ч. `code_tasks_created`. |

### Код-релевантность

В knowledge_applicator урок/инсайт считается код-релевантным, если в нём встречаются ключевые слова: код, test, api, валидация, ошибка, файл, модуль, функция, класс, база, запрос, безопасность, производительность, async, таймаут, retry, логирование и т.п. Такие уроки порождают задачи с `metadata.source = knowledge_applicator_code_improvement` и `assignee_hint = Backend Developer` (оркестратор назначит исполнителя).

---

## Итог

- **Правила:** знания по-прежнему попадают в .cursorrules (lessons + генерация из БД).
- **Задачи на код:** код-релевантные уроки и инсайты автоматически превращаются в задачи «Внедрить в код», которые обрабатывает воркер/агент.
- **Контекст при решении:** воркер при каждой задаче подтягивает релевантные знания по домену и подставляет их в промпт (ExpeL recall at inference).

Таким образом знания действительно ведут к улучшениям: и через правила, и через явные задачи на внедрение, и через контекст при выполнении.
