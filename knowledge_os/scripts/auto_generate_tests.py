#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
ü§ñ –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤ –¥–ª—è Python –º–æ–¥—É–ª–µ–π

–ê–≤—Ç–æ—Ä: –û–ª–µ–≥ (Automation Engineer)
–ú–µ–Ω—Ç–æ—Ä: –ê–Ω–Ω–∞ (QA) + –ò–≥–æ—Ä—å (Backend)
–î–∞—Ç–∞: November 23, 2025

–ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ:
    python scripts/auto_generate_tests.py --module lightgbm_predictor.py
    python scripts/auto_generate_tests.py --module risk_manager.py --output tests/unit/
    python scripts/auto_generate_tests.py --all --output tests/unit/
"""

import ast
import os
import argparse
import logging
from pathlib import Path
from typing import List, Dict, Set, Optional
import re

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class TestGenerator:
    """–ì–µ–Ω–µ—Ä–∞—Ç–æ—Ä —Ç–µ—Å—Ç–æ–≤ –¥–ª—è Python –º–æ–¥—É–ª–µ–π"""
    
    def __init__(self, module_path: str, output_dir: str = "tests/unit"):
        self.module_path = Path(module_path)
        self.output_dir = Path(output_dir)
        self.module_name = self.module_path.stem
        self.test_file_path = self.output_dir / f"test_{self.module_name}.py"
        
        # –ü–∞—Ä—Å–∏–º –º–æ–¥—É–ª—å
        try:
            with open(self.module_path, 'r', encoding='utf-8') as f:
                self.source_code = f.read()
            self.tree = ast.parse(self.source_code)
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ –ø–∞—Ä—Å–∏–Ω–≥–∞ –º–æ–¥—É–ª—è {module_path}: {e}")
            raise
    
    def extract_classes(self) -> List[Dict]:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç –∫–ª–∞—Å—Å—ã –∏–∑ –º–æ–¥—É–ª—è"""
        classes = []
        for node in ast.walk(self.tree):
            if isinstance(node, ast.ClassDef):
                methods = []
                for item in node.body:
                    if isinstance(item, ast.FunctionDef):
                        methods.append({
                            'name': item.name,
                            'args': [arg.arg for arg in item.args.args if arg.arg != 'self'],
                            'is_async': isinstance(item, ast.AsyncFunctionDef)
                        })
                
                classes.append({
                    'name': node.name,
                    'methods': methods,
                    'bases': [base.id for base in node.bases if isinstance(base, ast.Name)]
                })
        return classes
    
    def extract_functions(self) -> List[Dict]:
        """–ò–∑–≤–ª–µ–∫–∞–µ—Ç —Ñ—É–Ω–∫—Ü–∏–∏ –∏–∑ –º–æ–¥—É–ª—è"""
        functions = []
        for node in ast.walk(self.tree):
            if isinstance(node, ast.FunctionDef) and not any(
                isinstance(parent, ast.ClassDef) for parent in ast.walk(self.tree)
                if node in getattr(parent, 'body', [])
            ):
                functions.append({
                    'name': node.name,
                    'args': [arg.arg for arg in node.args.args],
                    'is_async': isinstance(node, ast.AsyncFunctionDef)
                })
        return functions
    
    def generate_imports(self) -> str:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –∏–º–ø–æ—Ä—Ç—ã –¥–ª—è —Ç–µ—Å—Ç–æ–≤"""
        imports = [
            "#!/usr/bin/env python3",
            "# -*- coding: utf-8 -*-",
            '"""',
            f"Unit tests for {self.module_name}.py",
            "",
            "Auto-generated by auto_generate_tests.py",
            "Author: –û–ª–µ–≥ (Automation Engineer)",
            '"""',
            "",
            "import pytest",
            "import unittest.mock as mock",
            "from unittest.mock import MagicMock, patch, AsyncMock",
            "",
        ]
        
        # –î–æ–±–∞–≤–ª—è–µ–º –∏–º–ø–æ—Ä—Ç –º–æ–¥—É–ª—è
        module_import_path = str(self.module_path).replace('/', '.').replace('\\', '.').replace('.py', '')
        imports.append(f"from {module_import_path} import *")
        imports.append("")
        
        return "\n".join(imports)
    
    def generate_class_tests(self, classes: List[Dict]) -> str:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–µ—Å—Ç—ã –¥–ª—è –∫–ª–∞—Å—Å–æ–≤"""
        tests = []
        
        for cls in classes:
            class_name = cls['name']
            test_class_name = f"Test{class_name}"
            
            tests.append(f"class {test_class_name}:")
            tests.append(f'    """Tests for {class_name} class"""')
            tests.append("")
            
            # Test __init__
            tests.append(f"    def test_init(self):")
            tests.append(f'        """Test initialization"""')
            tests.append(f"        # TODO: Implement test")
            tests.append(f"        pass")
            tests.append("")
            
            # Test methods
            for method in cls['methods']:
                method_name = method['name']
                if method_name.startswith('_') and not method_name.startswith('__'):
                    continue  # Skip private methods
                
                test_method_name = f"test_{method_name}"
                tests.append(f"    def {test_method_name}(self):")
                tests.append(f'        """Test {method_name} method"""')
                
                if method['is_async']:
                    tests.append(f"        # TODO: Implement async test")
                    tests.append(f"        # Use pytest.mark.asyncio")
                else:
                    tests.append(f"        # TODO: Implement test")
                
                tests.append(f"        pass")
                tests.append("")
        
        return "\n".join(tests)
    
    def generate_function_tests(self, functions: List[Dict]) -> str:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Ç–µ—Å—Ç—ã –¥–ª—è —Ñ—É–Ω–∫—Ü–∏–π"""
        tests = []
        
        for func in functions:
            func_name = func['name']
            if func_name.startswith('_'):
                continue  # Skip private functions
            
            test_func_name = f"test_{func_name}"
            tests.append(f"def {test_func_name}():")
            tests.append(f'    """Test {func_name} function"""')
            
            if func['is_async']:
                tests.append(f"    # TODO: Implement async test")
                tests.append(f"    # Use pytest.mark.asyncio")
            else:
                tests.append(f"    # TODO: Implement test")
            
            tests.append(f"    pass")
            tests.append("")
        
        return "\n".join(tests)
    
    def generate_test_file(self) -> str:
        """–ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –ø–æ–ª–Ω—ã–π —Ñ–∞–π–ª —Ç–µ—Å—Ç–æ–≤"""
        classes = self.extract_classes()
        functions = self.extract_functions()
        
        content = []
        content.append(self.generate_imports())
        content.append("")
        
        if classes:
            content.append(self.generate_class_tests(classes))
            content.append("")
        
        if functions:
            content.append(self.generate_function_tests(functions))
        
        return "\n".join(content)
    
    def save_test_file(self) -> bool:
        """–°–æ—Ö—Ä–∞–Ω—è–µ—Ç —Ñ–∞–π–ª —Ç–µ—Å—Ç–æ–≤"""
        try:
            # –°–æ–∑–¥–∞—ë–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏—é –µ—Å–ª–∏ –Ω–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç
            self.output_dir.mkdir(parents=True, exist_ok=True)
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º, —Å—É—â–µ—Å—Ç–≤—É–µ—Ç –ª–∏ —É–∂–µ —Ñ–∞–π–ª
            if self.test_file_path.exists():
                logger.warning(f"‚ö†Ô∏è –§–∞–π–ª {self.test_file_path} —É–∂–µ —Å—É—â–µ—Å—Ç–≤—É–µ—Ç. –ü—Ä–æ–ø—É—Å–∫–∞–µ–º.")
                return False
            
            # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º –∏ —Å–æ—Ö—Ä–∞–Ω—è–µ–º
            test_content = self.generate_test_file()
            with open(self.test_file_path, 'w', encoding='utf-8') as f:
                f.write(test_content)
            
            logger.info(f"‚úÖ –¢–µ—Å—Ç—ã —Å–æ–∑–¥–∞–Ω—ã: {self.test_file_path}")
            return True
        
        except Exception as e:
            logger.error(f"‚ùå –û—à–∏–±–∫–∞ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–µ—Å—Ç–æ–≤: {e}")
            return False
    
    def check_coverage(self) -> Dict:
        """–ü—Ä–æ–≤–µ—Ä—è–µ—Ç –ø–æ–∫—Ä—ã—Ç–∏–µ —Ç–µ—Å—Ç–∞–º–∏ (–±–∞–∑–æ–≤–∞—è –≤–µ—Ä—Å–∏—è)"""
        classes = self.extract_classes()
        functions = self.extract_functions()
        
        total_methods = sum(len(cls['methods']) for cls in classes) + len(functions)
        public_methods = sum(
            len([m for m in cls['methods'] if not m['name'].startswith('_')])
            for cls in classes
        ) + len([f for f in functions if not f['name'].startswith('_')])
        
        return {
            'total_methods': total_methods,
            'public_methods': public_methods,
            'classes': len(classes),
            'functions': len(functions)
        }


def find_python_modules(directory: str = ".") -> List[Path]:
    """–ù–∞—Ö–æ–¥–∏—Ç –≤—Å–µ Python –º–æ–¥—É–ª–∏ –≤ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏"""
    modules = []
    directory_path = Path(directory)
    
    # –ò—Å–∫–ª—é—á–∞–µ–º –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
    exclude_dirs = {'tests', '__pycache__', '.git', 'venv', '.venv', 'node_modules'}
    
    for py_file in directory_path.rglob("*.py"):
        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º —Ç–µ—Å—Ç—ã –∏ —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã–µ —Ñ–∞–π–ª—ã
        if 'test_' in py_file.name or py_file.name.startswith('_'):
            continue
        
        # –ü—Ä–æ–ø—É—Å–∫–∞–µ–º –∏—Å–∫–ª—é—á—ë–Ω–Ω—ã–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏
        if any(excluded in py_file.parts for excluded in exclude_dirs):
            continue
        
        modules.append(py_file)
    
    return modules


def main():
    """–ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è"""
    parser = argparse.ArgumentParser(description="–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∞—è –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Ç–µ—Å—Ç–æ–≤")
    parser.add_argument('--module', type=str, help='–ü—É—Ç—å –∫ –º–æ–¥—É–ª—é –¥–ª—è —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏—è')
    parser.add_argument('--all', action='store_true', help='–ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞—Ç—å —Ç–µ—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö –º–æ–¥—É–ª–µ–π')
    parser.add_argument('--output', type=str, default='tests/unit', help='–î–∏—Ä–µ–∫—Ç–æ—Ä–∏—è –¥–ª—è —Ç–µ—Å—Ç–æ–≤')
    parser.add_argument('--check-coverage', action='store_true', help='–ü—Ä–æ–≤–µ—Ä–∏—Ç—å –ø–æ–∫—Ä—ã—Ç–∏–µ')
    
    args = parser.parse_args()
    
    if args.all:
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–µ—Å—Ç—ã –¥–ª—è –≤—Å–µ—Ö –º–æ–¥—É–ª–µ–π
        modules = find_python_modules()
        logger.info(f"üìä –ù–∞–π–¥–µ–Ω–æ {len(modules)} –º–æ–¥—É–ª–µ–π")
        
        generated = 0
        skipped = 0
        
        for module_path in modules:
            try:
                generator = TestGenerator(str(module_path), args.output)
                if generator.save_test_file():
                    generated += 1
                else:
                    skipped += 1
            except Exception as e:
                logger.error(f"‚ùå –û—à–∏–±–∫–∞ –¥–ª—è {module_path}: {e}")
                skipped += 1
        
        logger.info(f"‚úÖ –°–æ–∑–¥–∞–Ω–æ —Ç–µ—Å—Ç–æ–≤: {generated}")
        logger.info(f"‚ö†Ô∏è –ü—Ä–æ–ø—É—â–µ–Ω–æ: {skipped}")
    
    elif args.module:
        # –ì–µ–Ω–µ—Ä–∏—Ä—É–µ–º —Ç–µ—Å—Ç—ã –¥–ª—è –æ–¥–Ω–æ–≥–æ –º–æ–¥—É–ª—è
        generator = TestGenerator(args.module, args.output)
        
        if args.check_coverage:
            coverage = generator.check_coverage()
            logger.info(f"üìä –ü–æ–∫—Ä—ã—Ç–∏–µ –¥–ª—è {args.module}:")
            logger.info(f"   –ö–ª–∞—Å—Å–æ–≤: {coverage['classes']}")
            logger.info(f"   –§—É–Ω–∫—Ü–∏–π: {coverage['functions']}")
            logger.info(f"   –ü—É–±–ª–∏—á–Ω—ã—Ö –º–µ—Ç–æ–¥–æ–≤: {coverage['public_methods']}")
        
        generator.save_test_file()
    
    else:
        parser.print_help()


if __name__ == "__main__":
    main()

