# Как мы мыслим: подход и логика обработки задач

**Назначение:** чтобы «мои» (команда и агенты) понимали **как я мыслю** — какой подход, какая последовательность шагов, какие принципы принятия решений. Один и тот же образ мышления можно применять и людям, и Victoria/экспертам: тогда решения предсказуемы и согласованы.

**Обновлено:** 2026-02-11

---

## 1. Для кого этот документ

- **Команда (люди):** понимать, по какой логике ассистент/Виктория разбирает задачу и что делать самому в той же манере.
- **Агенты (Victoria, эксперты):** при ответах пользователю опираться на эту схему — не импровизировать, а следовать цепочке: контекст → план → действие → проверка → обновление знаний.

---

## 2. Принципы (как я мыслю в основе)

| Принцип | Что это значит на практике |
|--------|----------------------------|
| **Делать как нужно** | Выполняю задачу по постановке, без лишних отклонений. Если формулировка неоднозначна — не додумываю, а **уточняю**. |
| **Один источник истины** | Сначала смотрю, что уже зафиксировано: библия (MASTER_REFERENCE и связанные доки), HOW_TO_INDEX, чеклисты. Не изобретаю заново то, что уже описано. |
| **Советоваться со специалистами** | При касании зоны (SRE, Backend, QA, БД, безопасность) — смотрю роли в `.cursor/rules/`, VERIFICATION_CHECKLIST, CHANGES_FROM_OTHER_CHATS и учитываю рекомендации и причины прошлых сбоев. |
| **Устранять причины, а не только следствия** | При баге или сбое фиксирую **корневую причину** (в коде, конфиге или доке). При следующих изменениях учитываю пункты «При следующих изменениях» в чеклисте. |
| **Проверять результат** | После правок — тесты, прогон затронутых сценариев. Если что-то сломалось — исправляю в той же итерации. |
| **Обновлять библию** | После изменений — обновляю MASTER_REFERENCE (раздел «Последние изменения» или соответствующий §) и при необходимости CHANGES_FROM_OTHER_CHATS, связанные доки. Библия всегда актуальна. |

---

## 3. Последовательность: как обрабатываю задачу

Вот **пошаговая логика** — от получения запроса до завершения.

### Шаг 1: Понять задачу

- Читаю формулировку цели/вопроса.
- Выделяю: **что именно нужно** (результат), **в каких границах** (файлы, сервисы, ограничения).
- Если не хватает данных или формулировка двусмысленна — **задаю уточняющий вопрос**, а не подставляю своё предположение.

### Шаг 2: Взять контекст (библия и документы)

- Открываю **MASTER_REFERENCE** и при необходимости связанные документы из §8 (архитектура, границы кода, цепочка задачи, что не сделано и т.д.).
- Если задача про «как что сделать» — смотрю **HOW_TO_INDEX**: тема → runbook или команда.
- Если задача про конкретный компонент (миграции, тесты, куратор, эксперты) — иду в соответствующий runbook (EXPERT_CONNECTION_ARCHITECTURE, CURATOR_RUNBOOK, TESTING_FULL_SYSTEM и т.д.).
- **Зачем:** не повторять уже принятые решения и не ломать то, что уже задокументировано (причины сбоев, границы src/ и knowledge_os, порядок запуска).

### Шаг 3: Спланировать или разбить

- Для простой задачи — одно действие (например «добавить строку в таблицу §8»).
- Для сложной — **разбиваю на шаги** (например: 1) прочитать текущее состояние, 2) внести правку, 3) запустить тесты, 4) обновить документ). При необходимости фиксирую план в ответе или в todo.
- Если задача касается зоны эксперта (БД, SRE, безопасность) — мысленно сверяюсь с чеклистом и «при следующих изменениях».

### Шаг 4: Выполнить

- Делаю только то, что входит в постановку и план.
- Не добавляю «заодно» непрошенные большие изменения; если вижу отдельную проблему — могу предложить её вынести в отдельную задачу.
- При изменении кода/конфигов — сохраняю согласованность с библией и границами (SRC_AND_KNOWLEDGE_OS_BOUNDARIES).

### Шаг 5: Проверить результат

- Запускаю релевантные тесты (например `pytest backend/app/tests/`, `pytest knowledge_os/tests/` или скрипт из TESTING_FULL_SYSTEM).
- Проверяю затронутый сценарий (если менял API — проверка вызова; если менял runbook — проверка, что команды и ссылки верные).
- Если что-то сломалось — исправляю в той же итерации, не оставляю «потом».

### Шаг 6: Зафиксировать в библии

- Обновляю **MASTER_REFERENCE**: «Последние изменения» и при необходимости соответствующий раздел или таблицу §8.
- При значимом изменении — добавляю запись в **CHANGES_FROM_OTHER_CHATS** (номер §, дата, что сделано, итог).
- Если добавил новый runbook или инструкцию — добавляю строку в **HOW_TO_INDEX** и при необходимости в WHATS_NOT_DONE §8.

---

## 4. Как принимаются решения

- **Есть явное правило или документ** (чеклист, runbook, NEXT_STEPS) — следую ему. Не подменяю своей интерпретацией.
- **Нет явного правила** — опираюсь на принципы выше (один источник истины, устранять причины, мировые практики). Если решение архитектурное или влияет на несколько зон — предлагаю зафиксировать его в документе (NEXT_STEPS, WHATS_NOT_DONE или отдельный дока).
- **Конфликт между «быстро сделать» и «сделать по библии»** — приоритет у согласованности с библией и чеклистом, иначе следующий человек или агент не поймёт, почему сделано иначе. Исключения явно фиксирую (например во временном решении с пометкой «до рефакторинга»).

---

## 5. Как обрабатываю неясности и ошибки

| Ситуация | Действие |
|----------|----------|
| Непонятная постановка | Задаю короткий уточняющий вопрос (что именно считать результатом, в каком объёме, есть ли ограничения). |
| Не нашёл в документации | Смотрю MASTER_REFERENCE §8 и HOW_TO_INDEX; если темы нет — предлагаю добавить после выполнения задачи. |
| Тесты упали после правки | Не оставляю падение: разбираю причину (мой код, фикстура, окружение) и исправляю или откатываю изменение. |
| Нашёл баг по ходу задачи | Если в scope задачи — фиксирую причину и правлю. Если вне scope — сообщаю и предлагаю вынести в отдельную задачу. |
| Уже есть противоречие в доке/коде | Сверяюсь с MASTER_REFERENCE и CHANGES; предлагаю одно согласованное состояние и правку (дока или кода). |

---

## 6. Краткая схема (шпаргалка для «моих»)

```
Запрос
  → Понять (при неясности — уточнить)
  → Контекст: библия + HOW_TO_INDEX + runbook по теме
  → План (шаги или одна операция)
  → Выполнить (в границах постановки и библии)
  → Проверить (тесты, сценарий)
  → Зафиксировать (MASTER_REFERENCE, CHANGES, при необходимости HOW_TO_INDEX)
```

**Для Victoria (логика мысли):** стратегия → память → план → выполнение → рефлексия (чекпоинты при провале шага) → ответ с confidence. Подробно: VICTORIA_TASK_CHAIN_FULL, PLAN_REASONING_LOGIC_VICTORIA.

Принципы: делать как нужно; один источник истины; советоваться со специалистами (роли, чеклист); устранять причины; проверять результат; обновлять библию.

---

## 7. Связь с другими документами

- **Методология в правилах:** .cursorrules («Методология работы»), MASTER_REFERENCE § «Как пользоваться» → «Методология работы».
- **Что делать по темам:** [HOW_TO_INDEX.md](HOW_TO_INDEX.md) — тема → runbook/команда.
- **Актуальное состояние проекта:** [MASTER_REFERENCE.md](MASTER_REFERENCE.md) и таблица документов §8.
- **Причины сбоев и что проверять:** VERIFICATION_CHECKLIST_OPTIMIZATIONS §3, §5; LIVING_ORGANISM_PREVENTION; PROBLEMS_AND_EXPERT_SOLUTIONS.

Когда «мои» (люди или агенты) следуют этой логике, подход и решения становятся предсказуемыми и согласованными с библией и командой.
