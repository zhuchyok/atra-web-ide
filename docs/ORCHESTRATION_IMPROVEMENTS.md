# Улучшение структуры оркестрации: кто кому распределяет, кто проверяет

Документ отвечает на вопросы: кто распределяет задачи, кто проверяет, кто пишет промпты; правильно ли, что «Veronica пишет промпты»; что должен делать оркестратор и как улучшить цепочки.

---

## 0. Кто лучше напишет план: Victoria, Orchestrator или Veronica?

**Рекомендация: план должен писать Victoria.** Это правильное и лучшее решение.

| Кто | Может писать план? | Почему да/нет |
|-----|--------------------|----------------|
| **Victoria** | **Да, лучше всех** | Видит полный контекст: запрос пользователя, структуру организации (отделы, эксперты из БД), решение «как» обрабатывать (отделы / делегировать / сама). Роль — стратег и продуктовый владелец. Имеет доступ к Extended Thinking, ReAct, знаниям корпорации. Единственная, кто при реалтайм-запросе знает и цель, и организацию. |
| **Orchestrator** | Только для задач из БД, косвенно | Не видит текст запроса пользователя в реалтайме — только записи в таблице `tasks` (title, description, domain_id). Может один раз вызвать Victoria («разложи эту задачу на подзадачи»), получить план и дальше создавать подзадачи в БД. Сам по себе план не пишет — поручает Victoria. |
| **Veronica** | **Нет** | Роль — исполнитель: получает от Victoria уже сформулированную задачу и выполняет. Не стратег, не видит общей картины запроса и отделов. План распределения по отделам/экспертам писать не должна. |

**Итог:** Предложение «план пишет Victoria» — правильное и лучшее. Orchestrator может *запросить* план у Victoria для сложных задач из БД; Veronica план не пишет.

---

## 0.1. Что должно быть в плане (подробно): кто какие задачи делает и через что

Чтобы план был полным и однозначным, в нём должны быть явно расписаны:

| Что в плане | Зачем | Как сейчас в коде (Victoria) |
|-------------|--------|-------------------------------|
| **Общее описание задачи** | `task_description` — что в итоге нужно получить | Есть; Victoria формирует из goal и структуры организации. |
| **Список подзадач** | Кто какую задачу делает | Есть: массив `subtasks`. |
| **По каждой подзадаче:** | | |
| — описание подзадачи | `subtask` — что именно сделать | Есть. |
| — отдел / департамент | `department` — к какому отделу относится | Есть. |
| — роль/эксперт | `expert_role` — кто выполняет (по роли или имени из БД) | Есть. |
| — приоритет | `priority` — high/medium/low | Есть. |
| — требования к результату | `requirements` — критерии приёмки | Есть. |
| — рекомендации по моделям | `recommended_models`, `model_selection` — через какую модель (Ollama/MLX) выполнять | Есть. |
| **Контекст** | `context` — важные детали для всех подзадач | Есть. |
| **Ожидаемый результат** | `expected_result` — итог по всей задаче | Есть. |
| **Порядок выполнения** | Неявно по порядку в массиве; при необходимости — явное «сначала 1, потом 2» | Можно усилить в промпте Victoria: «укажи порядок подзадач». |
| **Кто проверяет** | Управляющий отдела (Department Head) — сейчас задаётся по отделу в Task Distribution (`manager_review_task` по department) | В плане можно явно: «проверяющий по отделу X — такой-то эксперт/роль». |

**Итог:** В плане уже подробно расписано: кто (отдел, эксперт/роль) какие подзадачи делает, требования, приоритеты, рекомендации по моделям (через что выполнять). При желании можно усилить: явный порядок подзадач и явное указание проверяющего по отделу. Структура плана в коде (`victoria_enhanced.py`, `_think_and_create_prompt_for_veronica`) этому соответствует.

---

## 1. Текущие цепочки (как есть)

### Цепочка A: запрос пользователя → Victoria (чат/API/Telegram)

| Шаг | Кто | Действие |
|-----|-----|----------|
| 1 | **Victoria** | Решает: casual chat / просьба (Department Heads) / делегирование Veronica (8011) / сама (ReAct, simple, swarm). |
| 2a | **Victoria** | Если Department Heads: определяет отдел, **создаёт план задачи** (`_think_and_create_prompt_for_veronica` → в коде называется `veronica_prompt`, но **создаёт его Victoria**, не Veronica). |
| 2b | **Task Distribution** (в процессе Victoria) | **Распределяет**: парсит план (или вызывает Victoria снова для парсинга), создаёт назначения экспертам. |
| 3 | **Сотрудники (эксперты БД)** | Выполняют подзадачи через `ai_core.run_smart_agent_async` (локальные модели). |
| 4 | **Task Distribution** | **Проверяет**: `manager_review_task` — управляющий отдела (или Victoria по умолчанию) валидирует результат. |
| 5 | **Victoria** | Собирает результаты отдела, **синтезирует** финальный ответ пользователю. |

Делегирование на Veronica (8011): Victoria отправляет **конкретную задачу** (не план распределения) на порт 8011; Veronica **только выполняет** и возвращает ответ. Промпты для распределения по отделам Veronica **не пишет**.

### Цепочка B: задачи в БД → Enhanced Orchestrator

| Шаг | Кто | Действие |
|-----|-----|----------|
| 1 | **Enhanced Orchestrator** (фоновый цикл) | Читает задачи без исполнителя (`assignee_expert_id IS NULL`), приоритизирует, перебалансирует. |
| 2 | **Orchestrator** | **Назначает** одну задачу одному эксперту (`assign_task_to_best_expert`). Разложения на подзадачи нет. |
| 3 | **Smart Worker** (отдельный процесс) | Подхватывает назначенные задачи из БД, выполняет через `run_smart_agent_async`, помечает задачу `completed`. |
| 4 | **Проверка** | **Отсутствует** — после выполнения задача сразу считается завершённой, шага типа `manager_review` нет. |

Итог: в цепочке A распределяет Victoria + Task Distribution, проверяет Task Distribution (manager_review). В цепочке B распределяет только Orchestrator, проверки нет.

---

## 2. Кто что делает: правильное разделение ролей

### Кто должен писать промпты / планы

- **Victoria (Team Lead)** — стратег и продуктовый владелец:
  - Принимает запрос пользователя.
  - Решает: чат / просьба (разбить по отделам) / делегировать исполнителю / выполнить сама.
  - **Пишет план задачи** (декомпозиция, отделы, подзадачи) для системы распределения. В коде это сейчас называется `veronica_prompt`, но по смыслу это **план распределения (task plan)**, и создаёт его **Victoria**, не Veronica.

- **Veronica (порт 8011)** — исполнитель:
  - Получает от Victoria **уже сформулированную задачу** (найди, выполни, измени файл и т.д.).
  - **Не пишет** промпты для других и не распределяет задачи по отделам. Роль — только выполнение.

- **Task Distribution** — оркестрация внутри запроса:
  - Получает от Victoria **план** (текст/структура подзадач и отделов).
  - Назначает подзадачи экспертам, запускает выполнение, запускает **проверку** (manager_review), собирает результаты для Victoria.

Вывод: **правильно, что промпт для распределения пишет Victoria**. Название `veronica_prompt` в коде вводит в заблуждение: по сути это «план для Task Distribution», а не «промпт от Veronica».

### Кто распределяет задачи

- **Запрос пользователя (реалтайм):**  
  Victoria (решение + план) → Task Distribution (назначение по экспертам). Распределяет связка Victoria + Task Distribution.

- **Задачи из БД:**  
  Только **Enhanced Orchestrator** — назначает задачу одному эксперту, без декомпозиции.

### Кто проверяет

- **В цепочке A (Department Heads):**  
  Проверяет **Task Distribution** через `manager_review_task` (управляющий отдела или Victoria по умолчанию, при необходимости через TaskValidator).

- **В цепочке B (БД):**  
  **Никто** — проверки после выполнения Smart Worker нет.

---

## 3. Что не так и как улучшить

### 3.1. Название «veronica_prompt»

**Проблема:** По коду кажется, что «Veronica пишет промпты и передаёт дальше». На самом деле план пишет Victoria, использует Task Distribution.

**Рекомендация:**  
Переименовать концепт в коде и комментариях:

- `veronica_prompt` → `task_plan` или `distribution_brief` (план распределения от Victoria).
- В логах/документации явно писать: «план создан Victoria для Task Distribution».

Опционально: оставить параметр `veronica_prompt` в API для обратной совместимости, но внутри считать его «план от Victoria для распределения».

### 3.2. Оркестратор должен делать больше

**Сейчас:**  
Orchestrator только назначает одну задачу одному эксперту и не проверяет результат.

**Рекомендации:**

1. **Добавить проверку после выполнения (как в цепочке A)**  
   После того как Smart Worker помечает задачу `completed`, Orchestrator (или отдельный шаг в цикле) может:
   - вызывать логику, аналогичную `manager_review_task`: один эксперт/менеджер проверяет результат по формулировке задачи;
   - при провале проверки — переводить задачу обратно в `pending` и переназначать другому эксперту или той же задаче с уточнённым промптом.

2. **Опционально: декомпозиция сложных задач из БД**  
   Для задач с высоким приоритетом или помеченных как «сложные»:
   - Orchestrator один раз вызывает Victoria (например, `POST :8010/run` с целью «разложи эту задачу на подзадачи по отделам»);
   - по ответу создаёт в БД подзадачи и назначает их разным экспертам;
   - затем Smart Worker выполняет подзадачи, а проверка может быть на уровне каждой подзадачи или общей задачи.

Так цепочка БД по качеству и контролю приблизится к цепочке реального времени.

### 3.3. Двойной вызов Victoria при парсинге плана

**Сейчас:**  
Victoria создаёт план (текст с подзадачами/отделами). Task Distribution в `_parse_veronica_prompt` может снова вызывать `VictoriaEnhanced.solve()` для парсинга этого текста в JSON.

**Рекомендация:**  
В `_think_and_create_prompt_for_veronica` сразу возвращать не только текст, но и структурированный список подзадач (например, JSON). Task Distribution тогда использует готовую структуру и не вызывает Victoria второй раз для парсинга. Это уменьшит задержки и нагрузку.

### 3.4. Единое место проверки (опционально)

Чтобы не дублировать логику проверки:

- Вынести общую валидацию результата задачи в один модуль (например, на базе текущего `manager_review_task` / TaskValidator).
- В цепочке A: Task Distribution вызывает этот модуль после выполнения экспертами.
- В цепочке B: Orchestrator или Smart Worker после выполнения вызывает тот же модуль; при провале — повторное назначение или эскалация.

---

## 4. Итоговая таблица: кто кому что делает

| Роль | Распределяет задачи? | Пишет промпты/план? | Проверяет результат? |
|------|----------------------|---------------------|----------------------|
| **Victoria** | Решает «как» (отделы / делегировать / сама) | Да — план для Task Distribution (сейчас в коде «veronica_prompt») | Нет (синтезирует финальный ответ по уже проверенным результатам). |
| **Task Distribution** | Да — назначает подзадачи экспертам по плану Victoria | Нет | Да — `manager_review_task`. |
| **Veronica (8011)** | Нет | Нет — только выполняет задачу от Victoria | Нет. |
| **Enhanced Orchestrator** | Да — назначает задачи из БД одному эксперту | Нет | Сейчас нет — **рекомендуется добавить**. |
| **Smart Worker** | Нет | Нет | Нет. |
| **Эксперты (БД)** | Нет | Нет | Нет. |

---

## 5. Краткий чеклист улучшений

1. Переименовать/уточнить в коде и доке: «veronica_prompt» = план от Victoria для Task Distribution; Veronica (8011) промпты не пишет.
2. Добавить в цепочку БД шаг проверки после выполнения (аналог manager_review), желательно через общий модуль валидации.
3. (Опционально) Декомпозиция сложных задач из БД через один вызов Victoria и создание подзадач.
4. Убрать повторный вызов Victoria для парсинга плана: Victoria отдаёт структурированный план (JSON), Task Distribution его только использует.
5. Задокументировать в ARCHITECTURE_FULL.md роли и цепочки (кто распределяет, кто проверяет, кто пишет промпты) и ссылку на этот документ.

После этого структура обработки будет явной: Victoria пишет план и решает стратегию, Task Distribution и Orchestrator распределяют и (при внедрении пункта 2) проверяют, Veronica только исполняет.
