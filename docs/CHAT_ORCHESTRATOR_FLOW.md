# Чат и оркестратор: кто к кому обращается

**Дата:** 2026-01-29

## Как сейчас устроено

### Текущий поток

```
Пользователь → Frontend (чат) → Backend /api/chat/stream → Victoria POST /run
                                                                  │
                    Victoria /run:                                 │
                    1) IntegrationBridge.process_task(goal)  ──────┼── только запись для A/B (orchestrator_version)
                    2) detect_task_type → Veronica / Enhanced / agent.run()
                    3) Ответ возвращается в Backend → SSE → Frontend
```

- **Чат** всегда идёт в **backend** → **Victoria** (`POST /run`). Оркестратор (Knowledge OS) чат не обрабатывает.
- **Victoria** при выполнении задачи передаёт цель оркестратору: вызывается `IntegrationBridge.process_task(goal)`.
- **Оркестратор** по этой цели действительно:
  - **составляет план**: сложность, стратегия, при V2 — граф подзадач (TaskDecomposer), порядок выполнения;
  - **распределяет по сотрудникам**: Phase 5 — ExpertMatchingEngine / phase_5_select_experts → **assignments** (кто какую подзадачу ведёт, expert_name, модели).
- **Но** Victoria из ответа оркестратора сейчас берёт только `orchestrator_version` (v2 / existing) для **записи в A/B** в БД. План (strategy, graph, execution_order) и назначения (assignments) **не передаются** в логику выполнения: Victoria не использует их при вызове Veronica, Enhanced или `agent.run()`.
- **Само выполнение** по-прежнему решает Victoria: detect_task_type, use_enhanced, delegate_to_veronica / enhanced.solve() / agent.run().

**С 2026-01-29 (мировая практика):** Victoria сохраняет ответ оркестратора (`orchestration_plan`) и **использует** его при выполнении:
- Строится текст плана/назначений (`_build_orchestration_context(bridge_result)`) и передаётся в контекст LLM: в **Enhanced** и в **agent.run()** цель дополняется префиксом «План от оркестратора (следуй ему): стратегия, назначения».
- Если оркестратор назначил **Veronica** (по полю expert_name в assignments), Victoria сначала пробует **delegate_to_veronica**, затем при необходимости Enhanced / agent.run().
- То же поведение в фоновой задаче (`_run_task_background`).

Итог: **Victoria передаёт оркестратору цель → оркестратор составляет план и распределяет по сотрудникам → Victoria получает план и назначения и использует их при выполнении (контекст LLM + предпочтение Veronica при назначении).**

### Что делает оркестратор (IntegrationBridge / V2)

- **IntegrationBridge.process_task()** возвращает только план/назначения:
  - V2: `run_phases_1_to_5` → task_id, complexity, strategy, **assignments** (кто какой подзадачей занят);
  - existing: ExpertMatchingEngine → assignments.
- **Исполнения** (вызов Victoria/Veronica, запуск инструментов) оркестратор **не делает**. Выполнение всегда в Victoria: `delegate_to_veronica`, `enhanced.solve()` или `agent.run()`.

Итог: оркестратор сейчас — это **планирование и A/B-запись**, а не единая точка входа для чата.

---

## Два варианта развития

### Вариант A: Чат через оркестратор (единая точка входа)

Сделать оркестратор единственным входом для агентского чата:

```
Пользователь → Frontend → Backend → Knowledge OS POST /api/orchestrate/chat (или /api/v2/chat)
                                            │
                    Оркестратор:            │
                    1) process_task(goal) → план, assignments
                    2) по strategy/assignments решает: Victoria /run или Veronica
                    3) вызывает выбранного агента, возвращает результат
                    4) Backend отдаёт ответ в чат (SSE как сейчас)
```

Плюсы: один вход, вся маршрутизация и A/B в одном месте, проще добавлять новые агенты/стратегии.  
Минусы: нужен новый endpoint в Knowledge OS, перенос логики из Victoria в оркестратор (или дублирование вызовов Victoria/Veronica в оркестраторе).

### Вариант B: Оставить как сейчас, Victoria «сначала» к оркестратору

Оставить поток **Chat → Backend → Victoria /run**, но явно считать, что:

- Victoria **сначала** вызывает оркестратор только для **учёта** (A/B и, при желании, план/assignments).
- Дальше Victoria сама решает (task_type, use_enhanced) и выполняет: Veronica, Enhanced или `agent.run()`.

Тогда оркестратор не становится обработчиком чата, а остаётся «сервисом планирования и метрик», к которому Victoria обращается до выполнения.

При желании можно усилить: чтобы `IntegrationBridge.process_task()` (или V2) возвращал не только `orchestrator_version`, но и, например, рекомендацию «кого вызвать» (Victoria vs Veronica). Тогда Victoria могла бы сначала спросить оркестратор, потом уже вызывать себя или Veronica — но точка входа для чата по-прежнему Victoria.

---

## Рекомендация

- **Если нужен один «мозг» для всего (чат, задачи, маршрутизация)** — двигаться к **варианту A**: чат ходит в оркестратор (новый endpoint в Knowledge OS), оркестратор решает и дергает Victoria/Veronica.
- **Если достаточно, чтобы Victoria по-прежнему была точкой входа для чата**, а оркестратор — только планированием и A/B — оставить **вариант B** и при необходимости лишь расширить ответ оркестратора (например, рекомендация агента), не перенося вызов чата в Knowledge OS.

Сейчас реализован **вариант B**: Victoria обращается к оркестратору при поступлении задачи, но только для записи (и планирования в V2); выполнение целиком делает Victoria.

---

## Скорость: единая точка входа

**Единая точка лучше для скорости только если не добавляется лишний сетевой прыжок.**

| Схема | Прыжки до исполнения | Комментарий |
|-------|----------------------|-------------|
| **Сейчас (B)** | 1: Backend → Victoria | Оркестратор вызывается из Victoria (импорт/вызов в процессе) — не отдельный HTTP. Минимум задержки. |
| **Чат через оркестратор (A)** | 2: Backend → Orchestrator → Victoria/Veronica | Два прыжка → выше latency, если оркестратор — отдельный сервис. |
| **A, но оркестратор в том же процессе, что и backend** | 1: Backend (= оркестратор) → Victoria | Один прыжок; «единая точка» — это backend, в нём же живёт логика оркестратора. Оптимально по скорости. |

**Рекомендация для скорости:**

- Либо оставить **вход через Victoria** (вариант B): один хоп, оркестратор — только внутренний вызов у Victoria (как сейчас).
- Либо делать **единую точку в backend**: чат приходит в backend, в нём же вызывается оркестратор (как библиотека или тот же процесс), затем backend дергает Victoria/Veronica. Тогда «единая точка» = backend, без лишнего сетевого прыжка до отдельного оркестратора.
- Если вынести оркестратор в отдельный сервис и вести весь чат через него (Backend → Knowledge OS → Victoria), латентность вырастет на один round-trip, если только оркестратор и backend не на одном хосте с очень быстрой сетью.

---

## Как лучше сделать: всё рабочим и правильным? Через Victoria или через оркестратор?

### По качеству ответа — разницы нет (пока)

Сейчас оркестратор **не влияет на то, что вернётся пользователю**. Victoria передаёт ему задачу только для:
- записи в A/B (orchestrator_version),
- в V2 — план и assignments.

**Кто реально решает и отвечает:** Victoria (или делегирует Veronica / Enhanced). Решение «как выполнять» (task_type, use_enhanced, agent.run vs delegate) принимает **Victoria**, а не оркестратор. Результат оркестратора (план, assignments) в исполнение **не подмешивается** — Victoria его не использует для выбора агента или шагов.

Поэтому:
- **По уму и качеству ответа** при текущей реализации **нет разницы**: и «всё через Victoria», и «через оркестратор» дадут один и тот же ответ, потому что оркестратор ответ не формирует и логику выполнения не меняет.
- Разница только в **архитектуре** (кто точка входа) и в **скорости** (один прыжок через Victoria vs два через отдельный оркестратор).

### Что лучше для «всё рабочим и правильным»

| Критерий | Всё через Victoria (сейчас) | Всё через оркестратор |
|----------|----------------------------|------------------------|
| **Работоспособность** | Один контур: Backend → Victoria → ответ. Всё уже так и работает. | Нужен новый endpoint и логика «оркестратор вызвал агента и вернул результат». Больше мест, где что-то может сломаться. |
| **Правильность** | Один контракт (goal → result), одна точка, где живёт логика делегирования и инструментов. | Та же правильность, если оркестратор просто вызывает ту же Victoria/Veronica. |
| **Ум/качество** | Сейчас весь «ум» в Victoria (task_type, Enhanced, инструменты). | Без изменений в коде — такой же. Умнее через оркестратор станет только если **использовать** его вывод (план, assignments) для выбора агента и параметров выполнения. |
| **Скорость** | Меньше прыжков (один до Victoria). | Больше прыжков, если оркестратор — отдельный сервис. |

**Рекомендация для «всё рабочим и правильным»:**

1. **Оставить единые чаты через Victoria** — проще, уже работает, один прыжок, один контур. Оркестратор остаётся «внутри» Victoria (вызов для A/B и планирования). По качеству и уму при текущем коде разницы нет, потому что оркестратор ответ не формирует и не выбирает, кто выполнит.
2. **Делать «всё через оркестратор»** имеет смысл, если вы хотите:
   - перенести «мозг» (маршрутизацию, выбор агента) в оркестратор, и
   - реально использовать его ответ (assignments, strategy) при вызове Victoria/Veronica — тогда можно улучшать качество и ум уже в оркестраторе, не трогая Victoria.
3. **Гибрид:** точка входа по-прежнему Victoria, но решение «кого вызвать» частично берётся из оркестратора: например, оркестратор возвращает `recommendation: "veronica" | "victoria"` и Victoria этому следует. Тогда и один прыжок сохраняется, и оркестратор начинает влиять на ум/качество.

---

## Мировая практика: оркестратор распределяет, Victoria выполняет по плану

**Принцип:** Оркестратор лучше справляется с планированием и распределением по сотрудникам; он возвращает Victoria план и назначения, Victoria передаёт это в LLM и выполняет задачу по плану.

**Реализовано (2026-01-29):**

1. **Victoria** вызывает оркестратор (`IntegrationBridge.process_task(goal)`), сохраняет ответ в `orchestration_plan`.
2. **Хелперы:** `_build_orchestration_context(bridge_result)` — строит текст плана (стратегия, назначения, порядок выполнения); `_orchestrator_recommends_veronica(bridge_result)` — проверяет, назначил ли оркестратор Veronica.
3. **Передача плана в выполнение:**
   - В **Enhanced**: цель дополняется префиксом «План от оркестратора (следуй ему): …», контекст получает `orchestrator_plan`.
   - В **agent.run()**: цель дополняется тем же префиксом, чтобы исполнитель (LLM) видел план и назначения.
4. **Рекомендация исполнителя:** если в назначениях оркестратора есть эксперт Veronica/Вероника, Victoria сначала пробует **delegate_to_veronica**, затем при необходимости Enhanced или agent.run().
5. То же поведение в **фоновой задаче** (async_mode): оркестратор вызывается, план и назначения передаются в enhanced.solve и agent.run.

В итоге оркестратор отвечает за распределение и план, Victoria — за исполнение с учётом этого плана.
